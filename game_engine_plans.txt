mobsin_engine() {
	init() // Function to initiate and set up game
		// Add event listeners for keyboard and mouse
		// Starts the update loop
	update() // Overall game update - Rendering, physics updates, animation, game tick, etc.
	render(render_engine, canvas, w, h) // Function to be called to tell the game to render to a canvas. Takes width and height to set canvas
		// Enables rendering variable so that a render function is now called in the update() function
		// One could run just mobsin_engine() on the server side, and then run mobsin_render() on the client
	pause() // Toggles pausing of game - Stopping the update and render loop
	helper() { // Helper functions
		destroy(id) // Destroys an object given an object ID (Use the getId() method to obtain an object's ID). Only takes IDs so that it can consistently remove the object from the object and HUD arrays, as well as the workspace and HUD children list
		rand(min, max) // Random number between two given numbers
		transition(time, from, to, callback) // Transition a value between two values over a given time period and then call the callback
		waitC(secs, callback) // Wait for a callback using setTimeout()
		waitP(secs) // Wait to execute again using promise "async" functions
		getId(obj) // Get unique ID of given object
		findObj(id) // Get object based on ID (Use the getId() method to obtain an object's ID)
		getAllObjs() // Get all objects in the workspace as an iterable array
		dist(x1, y1, x2, y2) // Returns distance between two points.
		rayCast(x, y, ang, len) // Raycasting function. Returns ray start X and Y, and ray end X and Y. Can optionally return all objects collided with.
	}
	gameObjects // Array of all objects in the game world to iterate over
	hudObjects // Array of all objects in the HUD to iterate over
	physics // Holds functions and values for game physics
		colType // Collision detection type. Can be custom function by user or a provided function
		colDect
			AABB(obj1, obj2) // AABB collision detection - Takes obj1 and obj2 that both have .x, .y, .w and .h
			Vector(obj1, obj2) // Vector line collision detection - Takes obj1 and obj2 that both have .x, .y, .w and .h
		friction // Toggle friction on/off
		gravity // Toggle gravity on/off
		gravityPower // Sets gravity power, assuming gravity is enabled
	instance // Presets to instantiate pre-made game objects
		/*
			For an instance to exist in the game world, its function must be called.
			This sets the default properties for the object, as well as its unique ID.
			Then the user must call its .setParent() method.
				It becomes a child of an object (Usually the workspace object).
				It is also added to the game object list used for calling rendering and updating.
		*/
		group() // A generic object to group other objects as children beneath it or to use purely to store data
			data // Custom data that is not provided by the game engine, that the user can set
			// All data/custom properties about an object that the user wants to set that is not not already provided by the engine should only go inside the data property

			// Constants / Managed by game engine - Should not be altered by the user
			id // Unique ID of object
			children // Array of references to child objects. Should only be altered with the addChild() method

			// Methods
			addChild(obj) // Adds a child to the object.
			entry() // Function called as soon as the object changes parents
			update() // Function called each update. Optional			
		player() // Player object that can move, jump etc.
			// If this is a single player game and the engine resides on the user's machine only one player() should be instantiated and placed
			
			// Properties
			X
			Y
			W
			H
			velX // Velocity on X axis
			velY // Velocity on Y axis
			accel // Acceleration
			maxSpeed // Maximum velocity
			friction // Friction (Affecting both velX and velY)
			gravity // Whether the object is affected by gravity or not (Assuming gravity is enabled)
			weight // How fast an object falls relative to the game gravity (Assuming gravity is enabled)
			colour
			opacity // Opacity of the object
			noclip // If the player can collide with anything
			camera // A reference to which camera 
			data

			id
			children

			addChild(obj)
			entry()
			update()
		npc() // NPC object that is coded to be controlled by the server
			// Properties
			X
			Y
			W
			H
			velX
			velY
			gravity
			weight
			colour
			opacity
			noclip
			data

			id
			children

			addChild(obj)
			entry() // Function called as soon as the object is instantiated
			update() // Function called each update. Optional
		block() // A block, can have X, Y, W, and H. Toggle collisions, gravity, size, colour, picture, etc.
			// A block can be instantiated under either the workspace or the HUD. However, if it is in the HUD, it will have no physics and will not be collidable

			X
			Y
			W
			H
			colour
			opacity
			noclip
			data

			id
			children

			addChild(obj)
			entry()
			update()
		camera() // Create a unique camera that player view can be set to
			X
			Y

			id
			children

			addChild(obj)
			entry()
			update()
		textScreen() // A text element that can be dynamically changed
			// A text screen can be instantiated under either the workspace or the HUD. However, it cannot have physics applied to it.

			text // Actual text content
			X
			Y
			colour // Text fill colour
			size // Text size in PX
			font // Font face

			id

			entry()
			update()
	workspace // All objects in the game world - Will be translated and moved by player camera
	hud // All HUD objects that do not move on the screen regardless of where the player camera is
}

// EXAMPLE PSEUDO-CODE FOR GAME SETUP AND RUNNING
var game = new mobsin_engine(); // Instantiate game object
game.render(new mobsin_render(game), "#canvas", 480, 320); // Tell game to render to a canvas. The .render() method MUST ALWAYS be called before the .init() method.

// All elements can be added before the game update, just that no physics will apply and they can not be interacted with until the game is initiated

// Create a simple block
var block1 = new game.instance.block(); // Instantiate block
block1.x = block1.y = 100; // Set block X and Y pos
block1.w = block1.h = 50; // Set block width and height
block1.setParent(game.workspace); // Set block parent to workspace so it now exists in the physical world and is now in the game object array

var text1 = new game.instance.textScreen();
text1.text = "Welcome to MobSin."
text1.x = 200;
text1.y = 100;
text1.colour = "#00F";
text1.size = 20;
text1.font = "Impact";
text1.setParent(game.hud); // Set text parent to HUD so that it now renders on the screen and is now in the HUD object array

game.init(); // Initiate the game that will now be rendering the block

/*
	By default the game will render at position 0, 0
	Which camera is used as well as the camera position(s) can only be changed by first	instantiating a player (game.instance.player()), instantiating a camera (game.instance.camera()), setting their parents to workspace, then setting the player's current camera to the one that you just made
*/