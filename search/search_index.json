{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Whirl 2D JavaScript Game Engine Overview \u00b6 Whirl is a modern, lightweight and extensible 2D game engine written in JavaScript for use in the browser. It aims to provide you with the tools necessary to quickly and efficiently create fun and fast web games. Getting Started \u00b6 You can put something on the screen in under twenty lines of code and from there the world is your oyster . Visit the Getting Started section for a simple and easy setup guide that will introduce you to the basics getting up and running using the Whirl game engine. You can also follow along with the documentation as it will naturally take you through how the engine works, providing comprehensive explanations for each element of the engine coupled with useful examples. Documentation \u00b6 Full documentation concerning development with the Whirl game engine is in the Documentation section. It will give you extensive information in learning concepts within the engine, information on all game classes, installation and importation of the engine, as well as plenty of examples to go with documentation to help your understanding. Install \u00b6 Whirl takes advantage of webpack to compile its source code down into a single, usable JavaScript file. See the Installation section for instructions on compiling from source.","title":"Home"},{"location":"#overview","text":"Whirl is a modern, lightweight and extensible 2D game engine written in JavaScript for use in the browser. It aims to provide you with the tools necessary to quickly and efficiently create fun and fast web games.","title":"Overview"},{"location":"#getting-started","text":"You can put something on the screen in under twenty lines of code and from there the world is your oyster . Visit the Getting Started section for a simple and easy setup guide that will introduce you to the basics getting up and running using the Whirl game engine. You can also follow along with the documentation as it will naturally take you through how the engine works, providing comprehensive explanations for each element of the engine coupled with useful examples.","title":"Getting Started"},{"location":"#documentation","text":"Full documentation concerning development with the Whirl game engine is in the Documentation section. It will give you extensive information in learning concepts within the engine, information on all game classes, installation and importation of the engine, as well as plenty of examples to go with documentation to help your understanding.","title":"Documentation"},{"location":"#install","text":"Whirl takes advantage of webpack to compile its source code down into a single, usable JavaScript file. See the Installation section for instructions on compiling from source.","title":"Install"},{"location":"about/attributions/","text":"Attributions \u00b6 Logo - loading.io","title":"Attributions"},{"location":"about/attributions/#attributions","text":"Logo - loading.io","title":"Attributions"},{"location":"about/licence/","text":"Licence (MIT) \u00b6 MIT License Copyright (c) 2019 Matthew Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"Licence"},{"location":"about/licence/#licence-mit","text":"MIT License Copyright (c) 2019 Matthew Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"Licence (MIT)"},{"location":"documentation/classes/","text":"Game Classes \u00b6 All top-level classes are namespaced under the global Whirl object. Therefore, any top-level class documented here is implied to be a property of the Whirl object unless specifically under a sub-header of another class. All classes are initialised as you call them. You should not use the new keyword. Whirl \u00b6 The global Whirl object contains all the classes, constructors and constants that make up the Whirl game engine. Whirl Properties \u00b6 Constructors \u00b6 .Game() Returns a new Game instance object. .Sprite() Returns a new Sprite instance object. .Camera() Returns a new Camera instance object. .Text() Returns a new advanced Text instance object. .shapes An object containing constructors for shapes for use in bounding boxes. Functions \u00b6 .util An object containing various utility functions to assist in certain task. .math An object containing various mathematical functions and calculations. .easing An object containing functions for mathematical easing numerical values. Constants \u00b6 .STAGE Used in Viewport instantiation to indicate the engine to automatically create a new Stage . .CAMERA Used in Viewport instantiation to indicate to the engine to automatically create a new Camera . .Game() \u00b6 Returns a new instance of a Game object. The Game object is the actual running and workforce of the engine that updates your game, handles various object managers and deals with all interactions and rendering. Whirl.Game(<config>) Parameters \u00b6 Object <config> Preset configuration options for the Game instance. Boolean ignoreWarnings - Ignore debug warnings (Default: true ). Object or Boolean input - Enable or disable certain input event listeners. If you have a very large amount of game objects and are not using certain input methods then disabling certain listeners may yield a slight performance boost. Set to false to disable all inputs - useful if you just want to create some non-interactable animations or similar. Do not set or set to true to use the default input configuration (Listed below). Boolean mouse - Whether mouse event listeners should be attached to the document and existing and subsequent viewports (Default: true ). Boolean keyboard - Whether keyboard event listeners should be attached to the document (Default: true ). Boolean preventDefault - Whether any events (mouse or keyboard) should have their default browser behaviour prevented (Default: false ). HTMLElement keyElement - Element that listens for keyboard input events (Implicitly uses game.input.setKeyElement ) (Default: document.body ). HTMLElement mouseElement - Base element that listens for keyboard input events (Implicitly uses game.input.setMouseElement ) (Default: document.body ). DO NOT set this to a canvas element that any viewports are applied to. Any other properties given to the <config> object will be attached to the config object, too. Examples(s): Set all inputs to their defaults values. const myGame = Whirl.Game(); // or const myGame = Whirl.Game({ input: true }); myGame.config would then look like: { \"ignoreWarnings\": true, \"input\": { \"mouse\": true, \"keyboard\": true, \"preventDefault\": false } } Turn off all inputs. const myGame = Whirl.Game({ input: false }); myGame.config would then look like: { \"ignoreWarnings\": true, \"input\": false } Turn off all mouse input, use an <input> element text box to listen for keyboard events and prevent the default mouse and keyboard behaviour. // Get the input element const myInput = document.querySelector(\"input#myInput\"); const myGame = Whirl.Game({ input: { mouse: false, preventDefault: true, keyElement: myInput } }); myGame.config would then look like: { \"ignoreWarnings\": true, \"input\": { \"mouse\": false, \"keyboard\": true, \"preventDefault\": false, \"keyElement\": input#myInput } } Properties \u00b6 .config Object Persistent configuration of the Game instance. Also includes any additional properties given when initially creating a game instance. .ignoreWarnings - Ignore debug warnings. .input - See the input argument in the game instantiation parameters . After initialisation these properties should not be modified directly. .frameRate (Read-only) Integer Limits the maximum frames per second (FPS). Default 60 . .frameCount (Read-only) Integer The number of update frames elapsed since the game's start. Will only start counting once the game has been started with the Game.start() method, not when the game is instantiated. Methods \u00b6 .setup(<options>) Returns the Game object. Object <options> String canvas - Selector for an HTML5 <canvas> element. String canvasWidth or cW - Width in pixels to resize the canvas element to. String canvasHeight or cH - Height in pixels to resize the canvas element to. If a canvas width or height value is not given then the canvas will not be resized. Function setup - Called after the game has finished setting up (Called with the didSetup event). Funtion update - Called when the game will update - before the update loop occurs each frame (Called with the willUpdate event). Array assets - Array of assets to be loaded before the game is started. Implicitely calls the asset manager's .load method. Automatically sets up the game with a Viewport , Stage and Camera . This is not required to set up a game. Alternatively, a Viewport , Stage , Camera and assets can be set up manually. See the article \"Advanced: Setting Up From Scratch\" . Once setup has completed, the didSetup event is emitted on the game object and game loop is automatically started. Example(s): function gameSetup(data) { // Create objects, import assets, insert plugins, etc. } function gameLoop(data) { // Update object positions, detect key presses, animate sprites, etc. } const myGame = Whirl.Game() .setup({ setup: gameSetup, update: gameLoop, canvas: \"#myCanvas\", canvasWidth: 400, canvasHeight: 400 }); .start() Returns the Game object. Sets the Game.running flag to true . Emits the willStart event. Starts the update and render loop. By default the game does not start on creation, and must be started with this method. Will not execute if the game is already running. Example(s): const myGame = Whirl.Game() .start(); .stop() Returns the Game object. Sets the Game.running flag to false . Emits the willStop event. This is a request to stop the game loop. It will not take effect immediately, but at the beginning of the next available check. Therefore, an extra update tick may run even after calling .stop() . Example(s): const myGame = Whirl.Game() .start(); myGame.stop(); .Sprite() \u00b6 Returns a new instance of a Sprite.Rectangle() object unless specified otherwise. Sprites are visible \" things \" in your game world. They have a position, bounding box, a fill colour or image and a plethora of other properties that can be modified. All Sprites inherit from a Whirl.Sprite._baseSprite class and different types of Sprites extend the functionality of the base Sprite. Inherits the tween object system . Whirl.Sprite(<Game>, <name>, <fill>, <options>) By just calling Whirl.Sprite() it will return a Rectangle Sprite. Different types of sprites can be instantiated by adding .<Sprite Type>(...) . The following Sprite types are available: Whirl.Sprite.Rectangle(...) and Whirl.Sprite.Circle(...) . Parameters \u00b6 Object <Game> An already instantiated Game object. All sprites must be instantiated into an existing game instance so that they can be handled by the global object manager. String <name> A custom name for the Sprite. This name is used for identification as well as better indexing capabilities and searching the global object store. String or Object or NULL <fill> A colour or image to fill the Sprite with. Performs the same function as the .setFill(...) method. Providing a string will attempt to resolve the fill to a colour . Do not give colour values with transparency. Instead use the .alpha property. Example(s): rgb(0, 255, 220) or #F00 or cyan etc. If an object is given, it must be a Whirl.Asset image object. Most Sprite types will attempt to scale the image to their bounds . If null or any other non-valid fill value is given then the Sprite will be given a transparent colour fill by default. Object <options> String outline - String colour value for a one-pixel thick outline of the Sprite (Default: false ). Float alpha - Alpha/transparency for the Sprite ( 0 to 1 ) (Default: 1 ). Float scale - The scale of this Sprite - scales its bounding box size (Default: 1 ). Integer z - The z-index (Layer) of this Sprite (Default: 0 ). Properties \u00b6 .name String The name of the Sprite. Used by the global object manager to search for Sprites. ._fill (Read-only) Object Do not modify directly. Use the .setFill() method. Information about the Sprite's fill. .type - Type of fill. Can either be \" colour \" or \" image \". .data - Data of the fill. The colour value or the image asset. .outline String If not set to a falsey value, a one-pixel thick line of the given colour value will be drawn around the sprite. Not affected by the .alpha property. Typically used for debugging. .alpha Float Adjusts the alpha/transparency for the Sprite. Must only be between 0 and 1 . An alpha of 1 means the sprite is visible as normal. An alpha of 0 means the sprite is completely invisible. .scale Float Scales the Sprite's bounds by the given value. By default all Sprites scale from their top-left origin point, however this can be changed if the Sprite offers an anchor property. .z Integer The z-axis value for this Sprite. Allows for 'layering' of Sprites over one-another. A Sprite with a z value higher than another's will appear ontop of the other. Sprites with the same z value will be ordered by their initial order in the object store. Methods \u00b6 .setFill(<fill>) See the Sprite <fill> parameter . Returns the Sprite object. Example(s): mySprite.setFill(\"rgb(100, 255, 255)\"); mySprite.setFill(\"#F00\"); mySprite.setFill(\"blue\"); .tween. See the tween object system . .Rectangle() \u00b6 Returns a new instance of a rectangle Sprite object. Extends and inherits the base sprite parameters, properties and methods. Rectangle sprite bounds are defined by a top-left point and a width and height. Whirl.Sprite(<Game>, <name>, <fill>, <options>) // or Whirl.Sprite.Rectangle(<Game>, <name>, <fill>, <options>) Parameters \u00b6 Object <options> Number x - X-coordinate of the bounding box (Default: 0 ). Number y - Y-coordinate of the bounding box (Default: 0 ). Number w - Width of the bounding box (Default: 0 ). Number h - Height of the bounding box (Default: 0 ). Object anchor - Moves the anchor/origin point: Float x - X-coordinate of the anchor point (Default: 0 ). Float y - X-coordinate of the anchor point (Default: 0 ). Properties \u00b6 .bounds Object The bounding position and dimensions of this sprite. Derived from Whirl.shapes.Rectangle(...) . .x - X-coordinate of the bounding box. .y - Y-coordinate of the bounding box. .w - Width of the bounding box. .h - Height of the bounding box. .anchor Object Sets the anchor / origin point of the sprite's coordinates. .x - X-coordinate of the origin point. .y - Y-coordinate of the origin point. By default the x and y origin point are located at (0, 0) , the top-left point of the sprite. (1, 1) would be the bottom-right and (0.5, 0.5) would be the very center. Methods \u00b6 .resizeToImage(<scale>) Will not execute if the Sprite does not have an image fill type. Automatically sets the bounding box's width and height to the same dimensions as the image's width and height. Returns the Sprite object. Float <scale> Scales the width and height value of the Sprite after modifying it (Default: 1 ). .anchor.center() Sets the anchor point to (0.5, 0.5) . Returns the Sprite object. .Circle() \u00b6 Returns a new instance of a circle Sprite object. Extends and inherits the base sprite parameters, properties and methods. Circle sprites bounds are defined by a center point and a radius. Whirl.Sprite.Circle(<Game>, <name>, <fill>, <options>) Parameters \u00b6 Object <options> Number x - X-coordinate of the center point (Default: 0 ). Number y - Y-coordinate of the center point (Default: 0 ). Number r - Radius of the circle (Default: 0 ). Properties \u00b6 .bounds Object The bounding position and dimensions of this Sprite. Derived from Whirl.shapes.Circle(...) . .x - X-coordinate of the bounding box. .y - Y-coordinate of the bounding box. .r - Radius of the circle. .Camera() \u00b6 Returns a new instance of a Camera object. Cameras serve as the view into your world (the Stage ). Scrolling the camera around lets you look around different parts of your world. Cameras can be scrolled around, lock onto objects, zoom in/out, apply effects and more. Inherits the tween object system . Whirl.Camera(<Game>, <options>) Parameters \u00b6 Object <Game> An already instantiated Game object. Object <options> Number .x - X-coordinate of the bounding box (Default: 0 ). Number .y - Y-coordinate of the bounding box (Default: 0 ). Number .w - Width of the camera view (Default: 0 ). Number .h - Height of the camera view (Default: 0 ). Object anchor - Moves the anchor/origin point: Float x - X-coordinate of the anchor point (Default: 0 ). Float y - Y-coordinate of the anchor point (Default: 0 ). Object scroll - Scrolls the Camera view around the game world: Float x - X-coordinate of the scroll position (Default: 0 ). Float y - Y-coordinate of the scroll position (Default: 0 ). Float zoom - Zoom level of the Camera (Default: 1 ). Boolean roundPixels - Whether to round the scroll position to the nearest whole number (Default true ). Properties \u00b6 .bounds Object The position and dimensions of the Camera on screen. Derived from Whirl.shapes.Rectangle(...) . .x - X-coordinate of the bounding box. .y - Y-coordinate of the bounding box. .w - Width of the bounding box. .h - Height of the bounding box. Note that the .bounds property defines where the Camera will draw to on the screen , not where it will draw from in the world . Use the .scroll property to move around in space. The width and height properties do not cut off rendering on the screen, but are used to determine render culling zones and no-update zones. .anchor Object Sets the anchor / origin point of the camera's coordinates and zoom. .x - X-coordinate of the origin point. .y - Y-coordinate of the origin point. Has no effect if the Camera is following an object. ._followObject (Read-only) Object Do not modify directly. Use the .follow(...) and .unfollow() methods. Reference to the object that the Camera is following. .scroll Object The position in the world that the Camera is observing. Moves the camera's view around the game world. .x - X-coordinate of the scroll position. .y - Y-coordinate of the scroll position. Changing this will have no effect if the Camera is following an object ( ._followObject ) as its scroll position is bound to the object it is following. .zoom Number The zoom of the camera. Scales what the camera sees up/down by the given amount. Will always zoom around the anchor point. A zoom level of 1 (Default) means no scaling / a normal view. A zoom level of 2 would zoom in twice the normal amount - you would see half of normal view. A zoom level of .5 would zoom out twice the normal amount - you would see double the amount of the normal view. .roundPixels Rounds the scroll ( .scroll ) position to the nearest whole number if the Camera is locked to an object. Methods \u00b6 .follow(<Sprite>, <lerp>) Makes the camera follow the given Sprite by \"locking\" the camera's center point to the Sprite position. Returns the Camera object. Object <Sprite> Sprite object that the Camera should follow. Float <lerp> (Optional) (Default: 1 ) Implicitely calls .setLerp with the given <lerp> value. When a Camera follows a Sprite it will attempt to keep the Sprite in the exact center of the screen each update, moving the scroll ( .scroll ) position to the center of the Sprite's bounds by the linear interpolation value. Invokes the .anchor.center() method to center the Camera on the Sprite. Example(s): const mySprite = Whirl.Sprite(myGame, \"Blocky\", \"#F00\", { x: 100, y: 75, w: 50, h: 50 }); const myCamera = Whirl.Camera(myGame, { w: 400, h: 400 }) .follow(mySprite); .unfollow() Stops the camera following any object it is currently following ( ._followObject ). Returns the Camera object. When \"unlocked\", the scroll ( .scroll ) will stay in its last position that it was locked at, essentially not moving. The zoom ( .zoom ) and anchor ( .anchor ) positions remain unchanged throughout the time that the Camera is locked, so will still be the same after unlocking. Example(s): myCamera.unfollow(); .setLerp(<lerp>) Sets the linear interpolation that the camera uses to follow the Sprite. Has no effect if the Camera is not following an object ( ._followObject ). Returns the Camera object. Float <lerp> Linear interpolation value to use. Value between 0 and 1 . 1 means the Camera is locked to the object, anything below will make the Camera move slower to catch up to the Sprite. Example(s): myCamera.setLerp(1); myCamera.setLerp(.6); myCamera.setLerp(.1); .centerOn(<Sprite>) Moves the Camera's scroll position so that the Camera is centered on the given Sprite. Returns the Camera object. Object <Sprite> Sprite object that Camera centers on. Example(s): myCamera.centerOn(mySprite); .anchor.center() Sets the anchor point to (0.5, 0.5) . Returns the Camera object. .tween. See the tween object system . Stage \u00b6 A stage is the 'world' of your game that you put your game objects into. It used for keeping track of and updating game objects in the world. Objects not contained in a Stage are not rendered or updated. Stages and their contents are rendered using a Viewport and will update by themselves even when not being rendered. Inherits the child object system . <Game>.stageManager.add(<name>, <options>) <Game> represents an already instantiated game instance . The above code would return a reference to the Stage object as contained in the Stage Manager. Parameters \u00b6 String <name> A custom name for the Stage. This name is used for identification and is searched and indexed by the Stage Manager. Object <options> Number .x - X-coordinate of the stage limits (Default: 0 ). Number .y - Y-coordinate of the stage limits (Default: 0 ). Number .w - Width of the stage limits (Default: 0 ). Number .y - Height of the stage limits (Default: 0 ). Properties \u00b6 .name String The name of the Stage. Used by the stage and global object manager to search for Stages. .limits Object The limits of the game world. Objects with physics applied cannot leave the limits of the game world. Derived from Whirl.shapes.Rectangle(...) . .x - X-coordinate of the stage limits. .y - Y-coordinate of the stage limits. .w - Width of the stage limits. .h - Height of the stage limits. Methods \u00b6 .child. See the child object system . Objects must be contained inside a Stage using the child object system. Only objects that are children of a Stage are updated and/or rendered. Viewport \u00b6 A viewport is a screen that renders to an HTML5 Canvas. Viewports hold the render settings used by the canvas element and require a Stage and Camera to use for rendering. <Game>.viewportManager.add(<name>, <canvas>, <Stage>, <Camera>, <options>) <Game> represents an already instantiated game instance . The above code would return a reference to the Viewport object as contained in the Viewport Manager. Parameters \u00b6 String <name> A custom name for the Viewport. This name is used for identification and is searched and indexed by the Viewport Manager. String <canvas> Selector for a <canvas> element contained in the DOM. Performs the same function as the .setCanvas(...) method. Object or String <Stage> An already instantiated Stage object. Performs the same function as the .setStage(...) method. Alternatively, Whirl.STAGE can be given and a new Stage object will be automatically created and associated with the Viewport. Object or String <Camera> An already instantiated Camera object. Performs the same function as the .setCamera(...) method. Alternatively, Whirl.CAMERA can be given and a new Camera object with the same dimensions will be automatically created and associated with the Viewport. Object <options> Number x - X-coordinate of the bounding box (Default: 0 ). Number y - Y-coordinate of the bounding box (Default: 0 ). Number w - Width of the bounding box (Default: 0 ). Number h - Height of the bounding box (Default: 0 ). Integer cW - Resize the <canvas> element to a given width. Integer cH - Resize the <canvas> element to a given height. Boolean imageSmoothing - Canvas anti-aliasing enabled or not (Default: true ). Boolean clear - Clear canvas at the beginning of each render loop (Default: true ). Boolean clip - Clip out anything rendered beyond the Viewport's boundaries (Default: true ). Boolean fitCamera - Resize and move the Camera to the same coordinates and dimensions as the Viewport (Default: true ). Properties \u00b6 .name String The name of the Viewport. Used by the viewport and global object manager to search for Viewports. .bounds Object The bounding position and dimensions of this viewport on the screen. Derived from Whirl.shapes.Rectangle(...) . .x - X-coordinate of the bounding box. .y - Y-coordinate of the bounding box. .w - Width of the bounding box. .h - Height of the bounding box. Viewports should be static. Object clipping and screen clearing is based on the .bounds property and therefore it should not be modified after the initial definition in the <options> parameter. .c (Read-only) Object Do not modify directly. Use the .setCanvas(...) method. Reference to the HTML5 canvas element that the viewport will render to. This holds the actual element node, not just a selector or a copy. .ctx (Read-only) Object Do not modify directly. Use the .setCanvas(...) method. Reference to the drawing context of the viewport's canvas. .activeStage (Read-only) Object Do not modify directly. Use the .setStage(...) method. Reference to the Stage being rendered. .activeCamera (Read-only) Object Do not modify directly. Use the .setCamera(...) method. Reference to the Camera being used for rendering. .imageSmoothing Boolean Whether scaled images are smoothed (anti-aliased) or not. Useful for games that use pixel art a lot. .clear Boolean Clear the canvas at the beginning of every render loop. Only the area that the viewport occupies on the canvas is cleared. If the viewport has the same dimensions as the canvas then the entire canvas will be cleared. .clip Boolean Clip out anything in the entire canvas that is not within the viewport's boundaries. It is recommended to disable this if there is more than one viewport being used on the same canvas. Methods \u00b6 .setCanvas(<canvas>) Sets the HTML5 canvas element to render to. Also see the .c and .ctx viewport properties . Returns the Viewport object. String <canvas> Selector string for an HTML5 <canvas> element. Example(s): myViewport.setCanvas(\"#myCanvas\"); .setStage(<Stage>) Sets the current stage to be rendered. Also see the .activeStage viewport property . Returns the Viewport object. Object <Stage> An already instantiated Stage object. The Whirl.STAGE constant can be given instead and a new Stage object will be automatically created with the same position and dimensions as the viewport. .setCamera(<Camera>) Sets the current camera to be used for rendering. Also see the .activeCamera viewport property . Returns the Viewport object. Object <Camera> An already instantiated Camera object. The Whirl.CAMERA constant can be given instead and a new Camera object will be automatically created with the same position and dimensions as the viewport. If the fitCamera viewport parameter is not explicitly set to the false then the given camera will be repositioned and resized to the same position and dimensions of the viewport. .bringCamera() Returns the Viewport object. Moves the active camera 's scroll position to the top-left point of the viewport's position. If the viewport is placed anywhere that isnt (0, 0) it is recommended to bring the camera to avoid discrepancies between rendering zones and unwanted clipping of objects by the viewport after they have been rendered. Example(s): const myCamera = Whirl.Camera(myGame, { x: 50, y: 75, w: 200, h: 200 }); const myViewport = myGame.viewportManager.add(..., ..., ..., myCamera, { x: 0, y: 0, w: 400, h: 400 }) .bringCamera(); // The camera is now moved from (50, 75) and 200 width and height to (0, 0) and 400 width and height.","title":"Game Classes"},{"location":"documentation/classes/#game-classes","text":"All top-level classes are namespaced under the global Whirl object. Therefore, any top-level class documented here is implied to be a property of the Whirl object unless specifically under a sub-header of another class. All classes are initialised as you call them. You should not use the new keyword.","title":"Game Classes"},{"location":"documentation/classes/#whirl","text":"The global Whirl object contains all the classes, constructors and constants that make up the Whirl game engine. Whirl","title":"Whirl"},{"location":"documentation/classes/#properties","text":"","title":"Properties"},{"location":"documentation/classes/#constructors","text":".Game() Returns a new Game instance object. .Sprite() Returns a new Sprite instance object. .Camera() Returns a new Camera instance object. .Text() Returns a new advanced Text instance object. .shapes An object containing constructors for shapes for use in bounding boxes.","title":"Constructors"},{"location":"documentation/classes/#functions","text":".util An object containing various utility functions to assist in certain task. .math An object containing various mathematical functions and calculations. .easing An object containing functions for mathematical easing numerical values.","title":"Functions"},{"location":"documentation/classes/#constants","text":".STAGE Used in Viewport instantiation to indicate the engine to automatically create a new Stage . .CAMERA Used in Viewport instantiation to indicate to the engine to automatically create a new Camera .","title":"Constants"},{"location":"documentation/classes/#game","text":"Returns a new instance of a Game object. The Game object is the actual running and workforce of the engine that updates your game, handles various object managers and deals with all interactions and rendering. Whirl.Game(<config>)","title":".Game()"},{"location":"documentation/classes/#parameters","text":"Object <config> Preset configuration options for the Game instance. Boolean ignoreWarnings - Ignore debug warnings (Default: true ). Object or Boolean input - Enable or disable certain input event listeners. If you have a very large amount of game objects and are not using certain input methods then disabling certain listeners may yield a slight performance boost. Set to false to disable all inputs - useful if you just want to create some non-interactable animations or similar. Do not set or set to true to use the default input configuration (Listed below). Boolean mouse - Whether mouse event listeners should be attached to the document and existing and subsequent viewports (Default: true ). Boolean keyboard - Whether keyboard event listeners should be attached to the document (Default: true ). Boolean preventDefault - Whether any events (mouse or keyboard) should have their default browser behaviour prevented (Default: false ). HTMLElement keyElement - Element that listens for keyboard input events (Implicitly uses game.input.setKeyElement ) (Default: document.body ). HTMLElement mouseElement - Base element that listens for keyboard input events (Implicitly uses game.input.setMouseElement ) (Default: document.body ). DO NOT set this to a canvas element that any viewports are applied to. Any other properties given to the <config> object will be attached to the config object, too. Examples(s): Set all inputs to their defaults values. const myGame = Whirl.Game(); // or const myGame = Whirl.Game({ input: true }); myGame.config would then look like: { \"ignoreWarnings\": true, \"input\": { \"mouse\": true, \"keyboard\": true, \"preventDefault\": false } } Turn off all inputs. const myGame = Whirl.Game({ input: false }); myGame.config would then look like: { \"ignoreWarnings\": true, \"input\": false } Turn off all mouse input, use an <input> element text box to listen for keyboard events and prevent the default mouse and keyboard behaviour. // Get the input element const myInput = document.querySelector(\"input#myInput\"); const myGame = Whirl.Game({ input: { mouse: false, preventDefault: true, keyElement: myInput } }); myGame.config would then look like: { \"ignoreWarnings\": true, \"input\": { \"mouse\": false, \"keyboard\": true, \"preventDefault\": false, \"keyElement\": input#myInput } }","title":"Parameters"},{"location":"documentation/classes/#properties_1","text":".config Object Persistent configuration of the Game instance. Also includes any additional properties given when initially creating a game instance. .ignoreWarnings - Ignore debug warnings. .input - See the input argument in the game instantiation parameters . After initialisation these properties should not be modified directly. .frameRate (Read-only) Integer Limits the maximum frames per second (FPS). Default 60 . .frameCount (Read-only) Integer The number of update frames elapsed since the game's start. Will only start counting once the game has been started with the Game.start() method, not when the game is instantiated.","title":"Properties"},{"location":"documentation/classes/#methods","text":".setup(<options>) Returns the Game object. Object <options> String canvas - Selector for an HTML5 <canvas> element. String canvasWidth or cW - Width in pixels to resize the canvas element to. String canvasHeight or cH - Height in pixels to resize the canvas element to. If a canvas width or height value is not given then the canvas will not be resized. Function setup - Called after the game has finished setting up (Called with the didSetup event). Funtion update - Called when the game will update - before the update loop occurs each frame (Called with the willUpdate event). Array assets - Array of assets to be loaded before the game is started. Implicitely calls the asset manager's .load method. Automatically sets up the game with a Viewport , Stage and Camera . This is not required to set up a game. Alternatively, a Viewport , Stage , Camera and assets can be set up manually. See the article \"Advanced: Setting Up From Scratch\" . Once setup has completed, the didSetup event is emitted on the game object and game loop is automatically started. Example(s): function gameSetup(data) { // Create objects, import assets, insert plugins, etc. } function gameLoop(data) { // Update object positions, detect key presses, animate sprites, etc. } const myGame = Whirl.Game() .setup({ setup: gameSetup, update: gameLoop, canvas: \"#myCanvas\", canvasWidth: 400, canvasHeight: 400 }); .start() Returns the Game object. Sets the Game.running flag to true . Emits the willStart event. Starts the update and render loop. By default the game does not start on creation, and must be started with this method. Will not execute if the game is already running. Example(s): const myGame = Whirl.Game() .start(); .stop() Returns the Game object. Sets the Game.running flag to false . Emits the willStop event. This is a request to stop the game loop. It will not take effect immediately, but at the beginning of the next available check. Therefore, an extra update tick may run even after calling .stop() . Example(s): const myGame = Whirl.Game() .start(); myGame.stop();","title":"Methods"},{"location":"documentation/classes/#sprite","text":"Returns a new instance of a Sprite.Rectangle() object unless specified otherwise. Sprites are visible \" things \" in your game world. They have a position, bounding box, a fill colour or image and a plethora of other properties that can be modified. All Sprites inherit from a Whirl.Sprite._baseSprite class and different types of Sprites extend the functionality of the base Sprite. Inherits the tween object system . Whirl.Sprite(<Game>, <name>, <fill>, <options>) By just calling Whirl.Sprite() it will return a Rectangle Sprite. Different types of sprites can be instantiated by adding .<Sprite Type>(...) . The following Sprite types are available: Whirl.Sprite.Rectangle(...) and Whirl.Sprite.Circle(...) .","title":".Sprite()"},{"location":"documentation/classes/#parameters_1","text":"Object <Game> An already instantiated Game object. All sprites must be instantiated into an existing game instance so that they can be handled by the global object manager. String <name> A custom name for the Sprite. This name is used for identification as well as better indexing capabilities and searching the global object store. String or Object or NULL <fill> A colour or image to fill the Sprite with. Performs the same function as the .setFill(...) method. Providing a string will attempt to resolve the fill to a colour . Do not give colour values with transparency. Instead use the .alpha property. Example(s): rgb(0, 255, 220) or #F00 or cyan etc. If an object is given, it must be a Whirl.Asset image object. Most Sprite types will attempt to scale the image to their bounds . If null or any other non-valid fill value is given then the Sprite will be given a transparent colour fill by default. Object <options> String outline - String colour value for a one-pixel thick outline of the Sprite (Default: false ). Float alpha - Alpha/transparency for the Sprite ( 0 to 1 ) (Default: 1 ). Float scale - The scale of this Sprite - scales its bounding box size (Default: 1 ). Integer z - The z-index (Layer) of this Sprite (Default: 0 ).","title":"Parameters"},{"location":"documentation/classes/#properties_2","text":".name String The name of the Sprite. Used by the global object manager to search for Sprites. ._fill (Read-only) Object Do not modify directly. Use the .setFill() method. Information about the Sprite's fill. .type - Type of fill. Can either be \" colour \" or \" image \". .data - Data of the fill. The colour value or the image asset. .outline String If not set to a falsey value, a one-pixel thick line of the given colour value will be drawn around the sprite. Not affected by the .alpha property. Typically used for debugging. .alpha Float Adjusts the alpha/transparency for the Sprite. Must only be between 0 and 1 . An alpha of 1 means the sprite is visible as normal. An alpha of 0 means the sprite is completely invisible. .scale Float Scales the Sprite's bounds by the given value. By default all Sprites scale from their top-left origin point, however this can be changed if the Sprite offers an anchor property. .z Integer The z-axis value for this Sprite. Allows for 'layering' of Sprites over one-another. A Sprite with a z value higher than another's will appear ontop of the other. Sprites with the same z value will be ordered by their initial order in the object store.","title":"Properties"},{"location":"documentation/classes/#methods_1","text":".setFill(<fill>) See the Sprite <fill> parameter . Returns the Sprite object. Example(s): mySprite.setFill(\"rgb(100, 255, 255)\"); mySprite.setFill(\"#F00\"); mySprite.setFill(\"blue\"); .tween. See the tween object system .","title":"Methods"},{"location":"documentation/classes/#rectangle","text":"Returns a new instance of a rectangle Sprite object. Extends and inherits the base sprite parameters, properties and methods. Rectangle sprite bounds are defined by a top-left point and a width and height. Whirl.Sprite(<Game>, <name>, <fill>, <options>) // or Whirl.Sprite.Rectangle(<Game>, <name>, <fill>, <options>)","title":".Rectangle()"},{"location":"documentation/classes/#parameters_2","text":"Object <options> Number x - X-coordinate of the bounding box (Default: 0 ). Number y - Y-coordinate of the bounding box (Default: 0 ). Number w - Width of the bounding box (Default: 0 ). Number h - Height of the bounding box (Default: 0 ). Object anchor - Moves the anchor/origin point: Float x - X-coordinate of the anchor point (Default: 0 ). Float y - X-coordinate of the anchor point (Default: 0 ).","title":"Parameters"},{"location":"documentation/classes/#properties_3","text":".bounds Object The bounding position and dimensions of this sprite. Derived from Whirl.shapes.Rectangle(...) . .x - X-coordinate of the bounding box. .y - Y-coordinate of the bounding box. .w - Width of the bounding box. .h - Height of the bounding box. .anchor Object Sets the anchor / origin point of the sprite's coordinates. .x - X-coordinate of the origin point. .y - Y-coordinate of the origin point. By default the x and y origin point are located at (0, 0) , the top-left point of the sprite. (1, 1) would be the bottom-right and (0.5, 0.5) would be the very center.","title":"Properties"},{"location":"documentation/classes/#methods_2","text":".resizeToImage(<scale>) Will not execute if the Sprite does not have an image fill type. Automatically sets the bounding box's width and height to the same dimensions as the image's width and height. Returns the Sprite object. Float <scale> Scales the width and height value of the Sprite after modifying it (Default: 1 ). .anchor.center() Sets the anchor point to (0.5, 0.5) . Returns the Sprite object.","title":"Methods"},{"location":"documentation/classes/#circle","text":"Returns a new instance of a circle Sprite object. Extends and inherits the base sprite parameters, properties and methods. Circle sprites bounds are defined by a center point and a radius. Whirl.Sprite.Circle(<Game>, <name>, <fill>, <options>)","title":".Circle()"},{"location":"documentation/classes/#parameters_3","text":"Object <options> Number x - X-coordinate of the center point (Default: 0 ). Number y - Y-coordinate of the center point (Default: 0 ). Number r - Radius of the circle (Default: 0 ).","title":"Parameters"},{"location":"documentation/classes/#properties_4","text":".bounds Object The bounding position and dimensions of this Sprite. Derived from Whirl.shapes.Circle(...) . .x - X-coordinate of the bounding box. .y - Y-coordinate of the bounding box. .r - Radius of the circle.","title":"Properties"},{"location":"documentation/classes/#camera","text":"Returns a new instance of a Camera object. Cameras serve as the view into your world (the Stage ). Scrolling the camera around lets you look around different parts of your world. Cameras can be scrolled around, lock onto objects, zoom in/out, apply effects and more. Inherits the tween object system . Whirl.Camera(<Game>, <options>)","title":".Camera()"},{"location":"documentation/classes/#parameters_4","text":"Object <Game> An already instantiated Game object. Object <options> Number .x - X-coordinate of the bounding box (Default: 0 ). Number .y - Y-coordinate of the bounding box (Default: 0 ). Number .w - Width of the camera view (Default: 0 ). Number .h - Height of the camera view (Default: 0 ). Object anchor - Moves the anchor/origin point: Float x - X-coordinate of the anchor point (Default: 0 ). Float y - Y-coordinate of the anchor point (Default: 0 ). Object scroll - Scrolls the Camera view around the game world: Float x - X-coordinate of the scroll position (Default: 0 ). Float y - Y-coordinate of the scroll position (Default: 0 ). Float zoom - Zoom level of the Camera (Default: 1 ). Boolean roundPixels - Whether to round the scroll position to the nearest whole number (Default true ).","title":"Parameters"},{"location":"documentation/classes/#properties_5","text":".bounds Object The position and dimensions of the Camera on screen. Derived from Whirl.shapes.Rectangle(...) . .x - X-coordinate of the bounding box. .y - Y-coordinate of the bounding box. .w - Width of the bounding box. .h - Height of the bounding box. Note that the .bounds property defines where the Camera will draw to on the screen , not where it will draw from in the world . Use the .scroll property to move around in space. The width and height properties do not cut off rendering on the screen, but are used to determine render culling zones and no-update zones. .anchor Object Sets the anchor / origin point of the camera's coordinates and zoom. .x - X-coordinate of the origin point. .y - Y-coordinate of the origin point. Has no effect if the Camera is following an object. ._followObject (Read-only) Object Do not modify directly. Use the .follow(...) and .unfollow() methods. Reference to the object that the Camera is following. .scroll Object The position in the world that the Camera is observing. Moves the camera's view around the game world. .x - X-coordinate of the scroll position. .y - Y-coordinate of the scroll position. Changing this will have no effect if the Camera is following an object ( ._followObject ) as its scroll position is bound to the object it is following. .zoom Number The zoom of the camera. Scales what the camera sees up/down by the given amount. Will always zoom around the anchor point. A zoom level of 1 (Default) means no scaling / a normal view. A zoom level of 2 would zoom in twice the normal amount - you would see half of normal view. A zoom level of .5 would zoom out twice the normal amount - you would see double the amount of the normal view. .roundPixels Rounds the scroll ( .scroll ) position to the nearest whole number if the Camera is locked to an object.","title":"Properties"},{"location":"documentation/classes/#methods_3","text":".follow(<Sprite>, <lerp>) Makes the camera follow the given Sprite by \"locking\" the camera's center point to the Sprite position. Returns the Camera object. Object <Sprite> Sprite object that the Camera should follow. Float <lerp> (Optional) (Default: 1 ) Implicitely calls .setLerp with the given <lerp> value. When a Camera follows a Sprite it will attempt to keep the Sprite in the exact center of the screen each update, moving the scroll ( .scroll ) position to the center of the Sprite's bounds by the linear interpolation value. Invokes the .anchor.center() method to center the Camera on the Sprite. Example(s): const mySprite = Whirl.Sprite(myGame, \"Blocky\", \"#F00\", { x: 100, y: 75, w: 50, h: 50 }); const myCamera = Whirl.Camera(myGame, { w: 400, h: 400 }) .follow(mySprite); .unfollow() Stops the camera following any object it is currently following ( ._followObject ). Returns the Camera object. When \"unlocked\", the scroll ( .scroll ) will stay in its last position that it was locked at, essentially not moving. The zoom ( .zoom ) and anchor ( .anchor ) positions remain unchanged throughout the time that the Camera is locked, so will still be the same after unlocking. Example(s): myCamera.unfollow(); .setLerp(<lerp>) Sets the linear interpolation that the camera uses to follow the Sprite. Has no effect if the Camera is not following an object ( ._followObject ). Returns the Camera object. Float <lerp> Linear interpolation value to use. Value between 0 and 1 . 1 means the Camera is locked to the object, anything below will make the Camera move slower to catch up to the Sprite. Example(s): myCamera.setLerp(1); myCamera.setLerp(.6); myCamera.setLerp(.1); .centerOn(<Sprite>) Moves the Camera's scroll position so that the Camera is centered on the given Sprite. Returns the Camera object. Object <Sprite> Sprite object that Camera centers on. Example(s): myCamera.centerOn(mySprite); .anchor.center() Sets the anchor point to (0.5, 0.5) . Returns the Camera object. .tween. See the tween object system .","title":"Methods"},{"location":"documentation/classes/#stage","text":"A stage is the 'world' of your game that you put your game objects into. It used for keeping track of and updating game objects in the world. Objects not contained in a Stage are not rendered or updated. Stages and their contents are rendered using a Viewport and will update by themselves even when not being rendered. Inherits the child object system . <Game>.stageManager.add(<name>, <options>) <Game> represents an already instantiated game instance . The above code would return a reference to the Stage object as contained in the Stage Manager.","title":"Stage"},{"location":"documentation/classes/#parameters_5","text":"String <name> A custom name for the Stage. This name is used for identification and is searched and indexed by the Stage Manager. Object <options> Number .x - X-coordinate of the stage limits (Default: 0 ). Number .y - Y-coordinate of the stage limits (Default: 0 ). Number .w - Width of the stage limits (Default: 0 ). Number .y - Height of the stage limits (Default: 0 ).","title":"Parameters"},{"location":"documentation/classes/#properties_6","text":".name String The name of the Stage. Used by the stage and global object manager to search for Stages. .limits Object The limits of the game world. Objects with physics applied cannot leave the limits of the game world. Derived from Whirl.shapes.Rectangle(...) . .x - X-coordinate of the stage limits. .y - Y-coordinate of the stage limits. .w - Width of the stage limits. .h - Height of the stage limits.","title":"Properties"},{"location":"documentation/classes/#methods_4","text":".child. See the child object system . Objects must be contained inside a Stage using the child object system. Only objects that are children of a Stage are updated and/or rendered.","title":"Methods"},{"location":"documentation/classes/#viewport","text":"A viewport is a screen that renders to an HTML5 Canvas. Viewports hold the render settings used by the canvas element and require a Stage and Camera to use for rendering. <Game>.viewportManager.add(<name>, <canvas>, <Stage>, <Camera>, <options>) <Game> represents an already instantiated game instance . The above code would return a reference to the Viewport object as contained in the Viewport Manager.","title":"Viewport"},{"location":"documentation/classes/#parameters_6","text":"String <name> A custom name for the Viewport. This name is used for identification and is searched and indexed by the Viewport Manager. String <canvas> Selector for a <canvas> element contained in the DOM. Performs the same function as the .setCanvas(...) method. Object or String <Stage> An already instantiated Stage object. Performs the same function as the .setStage(...) method. Alternatively, Whirl.STAGE can be given and a new Stage object will be automatically created and associated with the Viewport. Object or String <Camera> An already instantiated Camera object. Performs the same function as the .setCamera(...) method. Alternatively, Whirl.CAMERA can be given and a new Camera object with the same dimensions will be automatically created and associated with the Viewport. Object <options> Number x - X-coordinate of the bounding box (Default: 0 ). Number y - Y-coordinate of the bounding box (Default: 0 ). Number w - Width of the bounding box (Default: 0 ). Number h - Height of the bounding box (Default: 0 ). Integer cW - Resize the <canvas> element to a given width. Integer cH - Resize the <canvas> element to a given height. Boolean imageSmoothing - Canvas anti-aliasing enabled or not (Default: true ). Boolean clear - Clear canvas at the beginning of each render loop (Default: true ). Boolean clip - Clip out anything rendered beyond the Viewport's boundaries (Default: true ). Boolean fitCamera - Resize and move the Camera to the same coordinates and dimensions as the Viewport (Default: true ).","title":"Parameters"},{"location":"documentation/classes/#properties_7","text":".name String The name of the Viewport. Used by the viewport and global object manager to search for Viewports. .bounds Object The bounding position and dimensions of this viewport on the screen. Derived from Whirl.shapes.Rectangle(...) . .x - X-coordinate of the bounding box. .y - Y-coordinate of the bounding box. .w - Width of the bounding box. .h - Height of the bounding box. Viewports should be static. Object clipping and screen clearing is based on the .bounds property and therefore it should not be modified after the initial definition in the <options> parameter. .c (Read-only) Object Do not modify directly. Use the .setCanvas(...) method. Reference to the HTML5 canvas element that the viewport will render to. This holds the actual element node, not just a selector or a copy. .ctx (Read-only) Object Do not modify directly. Use the .setCanvas(...) method. Reference to the drawing context of the viewport's canvas. .activeStage (Read-only) Object Do not modify directly. Use the .setStage(...) method. Reference to the Stage being rendered. .activeCamera (Read-only) Object Do not modify directly. Use the .setCamera(...) method. Reference to the Camera being used for rendering. .imageSmoothing Boolean Whether scaled images are smoothed (anti-aliased) or not. Useful for games that use pixel art a lot. .clear Boolean Clear the canvas at the beginning of every render loop. Only the area that the viewport occupies on the canvas is cleared. If the viewport has the same dimensions as the canvas then the entire canvas will be cleared. .clip Boolean Clip out anything in the entire canvas that is not within the viewport's boundaries. It is recommended to disable this if there is more than one viewport being used on the same canvas.","title":"Properties"},{"location":"documentation/classes/#methods_5","text":".setCanvas(<canvas>) Sets the HTML5 canvas element to render to. Also see the .c and .ctx viewport properties . Returns the Viewport object. String <canvas> Selector string for an HTML5 <canvas> element. Example(s): myViewport.setCanvas(\"#myCanvas\"); .setStage(<Stage>) Sets the current stage to be rendered. Also see the .activeStage viewport property . Returns the Viewport object. Object <Stage> An already instantiated Stage object. The Whirl.STAGE constant can be given instead and a new Stage object will be automatically created with the same position and dimensions as the viewport. .setCamera(<Camera>) Sets the current camera to be used for rendering. Also see the .activeCamera viewport property . Returns the Viewport object. Object <Camera> An already instantiated Camera object. The Whirl.CAMERA constant can be given instead and a new Camera object will be automatically created with the same position and dimensions as the viewport. If the fitCamera viewport parameter is not explicitly set to the false then the given camera will be repositioned and resized to the same position and dimensions of the viewport. .bringCamera() Returns the Viewport object. Moves the active camera 's scroll position to the top-left point of the viewport's position. If the viewport is placed anywhere that isnt (0, 0) it is recommended to bring the camera to avoid discrepancies between rendering zones and unwanted clipping of objects by the viewport after they have been rendered. Example(s): const myCamera = Whirl.Camera(myGame, { x: 50, y: 75, w: 200, h: 200 }); const myViewport = myGame.viewportManager.add(..., ..., ..., myCamera, { x: 0, y: 0, w: 400, h: 400 }) .bringCamera(); // The camera is now moved from (50, 75) and 200 width and height to (0, 0) and 400 width and height.","title":"Methods"},{"location":"documentation/constants/","text":"keys \u00b6 Maps English keyboard characters to their respective key codes and vice-versa. Primarily used in keyboard input to write key names instead of key codes. Whirl.keys The keys listed below are in JSON file-format and are also accessed as such. \"a\": 65, \"b\": 66, \"c\": 67, \"d\": 68, \"e\": 69, \"f\": 70, \"g\": 71, \"h\": 72, \"i\": 73, \"j\": 74, \"k\": 75, \"l\": 76, \"m\": 77, \"n\": 78, \"o\": 79, \"p\": 80, \"q\": 81, \"r\": 82, \"s\": 83, \"t\": 84, \"u\": 85, \"v\": 86, \"w\": 87, \"x\": 88, \"y\": 89, \"z\": 90, \"0\": 48, \"1\": 49, \"2\": 50, \"3\": 51, \"4\": 52, \"5\": 53, \"6\": 54, \"7\": 55, \"8\": 56, \"9\": 57, \"ArrowUp\": 38, \"ArrowRight\": 39, \"ArrowDown\": 40, \"ArrowLeft\": 37, \"Shift\": 16, \"Space\": 32, \"Alt\": 18, \"Control\": 17, \"Minus\": 189, \"Equal\": 187, \"Backquote\": 192, \"Comma\": 188, \"Period\": 190, \"Slash\": 191 Example(s): Whirl.keys[\"x\"]; // 88 Whirl.keys[\"ArrowRight\"]; // 39 Whirl.keys[\"Shift\"]; // 16 Keys can also be searched for in reverse using the getByKeyCode method. Example(s): Whirl.keys.getByKeyCode(88); // \"x\" Whirl.keys.getByKeyCode(39); // \"ArrowRight\" Whirl.keys.getByKeyCode(16); // \"Shift\" STAGE \u00b6 Returns the constant string \" _DEFAULTSTAGE \". Used in viewport instantiation to automatically set up a default Stage object instead of providing an already created one. Whirl.STAGE The newly instantiated stage will automatically have the same dimensions as the viewport. CAMERA \u00b6 Returns the constant string \" _DEFAULTCAMERA \". Used in viewport instantiation to automatically set up a default Camera object instead of providing an already created one. Whirl.CAMERA The newly instantiated camera will automatically have the same position and dimensions as the viewport.","title":"Constants"},{"location":"documentation/constants/#keys","text":"Maps English keyboard characters to their respective key codes and vice-versa. Primarily used in keyboard input to write key names instead of key codes. Whirl.keys The keys listed below are in JSON file-format and are also accessed as such. \"a\": 65, \"b\": 66, \"c\": 67, \"d\": 68, \"e\": 69, \"f\": 70, \"g\": 71, \"h\": 72, \"i\": 73, \"j\": 74, \"k\": 75, \"l\": 76, \"m\": 77, \"n\": 78, \"o\": 79, \"p\": 80, \"q\": 81, \"r\": 82, \"s\": 83, \"t\": 84, \"u\": 85, \"v\": 86, \"w\": 87, \"x\": 88, \"y\": 89, \"z\": 90, \"0\": 48, \"1\": 49, \"2\": 50, \"3\": 51, \"4\": 52, \"5\": 53, \"6\": 54, \"7\": 55, \"8\": 56, \"9\": 57, \"ArrowUp\": 38, \"ArrowRight\": 39, \"ArrowDown\": 40, \"ArrowLeft\": 37, \"Shift\": 16, \"Space\": 32, \"Alt\": 18, \"Control\": 17, \"Minus\": 189, \"Equal\": 187, \"Backquote\": 192, \"Comma\": 188, \"Period\": 190, \"Slash\": 191 Example(s): Whirl.keys[\"x\"]; // 88 Whirl.keys[\"ArrowRight\"]; // 39 Whirl.keys[\"Shift\"]; // 16 Keys can also be searched for in reverse using the getByKeyCode method. Example(s): Whirl.keys.getByKeyCode(88); // \"x\" Whirl.keys.getByKeyCode(39); // \"ArrowRight\" Whirl.keys.getByKeyCode(16); // \"Shift\"","title":"keys"},{"location":"documentation/constants/#stage","text":"Returns the constant string \" _DEFAULTSTAGE \". Used in viewport instantiation to automatically set up a default Stage object instead of providing an already created one. Whirl.STAGE The newly instantiated stage will automatically have the same dimensions as the viewport.","title":"STAGE"},{"location":"documentation/constants/#camera","text":"Returns the constant string \" _DEFAULTCAMERA \". Used in viewport instantiation to automatically set up a default Camera object instead of providing an already created one. Whirl.CAMERA The newly instantiated camera will automatically have the same position and dimensions as the viewport.","title":"CAMERA"},{"location":"documentation/customisation/","text":"Plugins \u00b6 Custom Objects \u00b6 Custom Sprites \u00b6","title":"Customisation"},{"location":"documentation/customisation/#plugins","text":"","title":"Plugins"},{"location":"documentation/customisation/#custom-objects","text":"","title":"Custom Objects"},{"location":"documentation/customisation/#custom-sprites","text":"","title":"Custom Sprites"},{"location":"documentation/install/","text":"Installation \u00b6 Whirl is designed to be capable of running offline and in the browser. You first need to compile the library from the source and then include it in your project. 1. Clone the repository. git clone https://github.com/MatthewWid/Whirl.git 2. Navigate to the root directory. cd \"Whirl\" 3. Install dependencies. npm install 4. Build the source. npm run prod You should now see that a file called whirl.js has appeared in the /build/ directory. Usage \u00b6 Once you have a copy of the compiled source you can include it into your project: <script src=\"whirl.js\"></script> or const Whirl = require(\"whirl.js\"); Alternatively, you can simply open the index.html file in any of the example projects in the /examples/ directory to quickly mess around with and observe what the engine is capable of.","title":"Installation"},{"location":"documentation/install/#installation","text":"Whirl is designed to be capable of running offline and in the browser. You first need to compile the library from the source and then include it in your project. 1. Clone the repository. git clone https://github.com/MatthewWid/Whirl.git 2. Navigate to the root directory. cd \"Whirl\" 3. Install dependencies. npm install 4. Build the source. npm run prod You should now see that a file called whirl.js has appeared in the /build/ directory.","title":"Installation"},{"location":"documentation/install/#usage","text":"Once you have a copy of the compiled source you can include it into your project: <script src=\"whirl.js\"></script> or const Whirl = require(\"whirl.js\"); Alternatively, you can simply open the index.html file in any of the example projects in the /examples/ directory to quickly mess around with and observe what the engine is capable of.","title":"Usage"},{"location":"documentation/libraries/","text":"In-Built Libraries \u00b6 Below is documentation for libraries that Whirl provides that aren't necessarily needed when creating a game but can be convenient so as to not reinvent the wheel with common operations you may do as part of a game. Such libraries include general utility functions, mathematical functions and easing functions. Utility Functions \u00b6 Library of general utility functions. Whirl.util.<function> Format Comma \u00b6 Format a number to a string separating thousands with commas. Whirl.util.formatComma(<number>) Integer <number> Number to be formatted. Example(s): Whirl.util.formatComma(1); // \"1\" Whirl.util.formatComma(1000); // \"1,000\" Whirl.util.formatComma(3985721); // \"3,985,721\" Whirl.util.formatComma(9874.56); // \"9,874.56\" Random Value from Array \u00b6 Returns a random value from a given array. Whirl.util.randArr(<arr>) Array <arr> Array to retrieve a random value from. Example(s): Whirl.util.randArr([1, 5, 2]); // 5 Whirl.util.randArr([1, 5, 2]); // 2 Whirl.util.randArr([3, 8, 9]); // 9 Random HSL \u00b6 Returns a random HSL (Hue, Saturation, Lightness) value of either a string or JSON object ( hsl(h, s, l) ). Whirl.util.randHSL(<cfg>) Object <cfg> Object that provides optional configuration variables when generating the HSL value. alpha - If given, the given alpha value will also be given with the generated value ( hsl(h, s, l, a) ). json - If true , will return a JSON representation of the HSL value instead of a string. sat - If given, will override the generated saturation value with the given value. lit - If given, will override the generated lightness value with the given value. Example(s): Whirl.util.randHSL(); // \"hsl(39, 3%, 7%)\" Whirl.util.randHSL(); // \"hsl(48, 85%, 78%)\" Whirl.util.randHSL({alpha: true}); // \"hsla(85, 15%, 67%, 0.8)\" Whirl.util.randHSL({json: true}); // {hue: 177, sat: 20, lit: 27} Whirl.util.randHSL({alpha: true, json: true}); // {hue: 174, sat: 66, lit: 40, a: 0.8} Whirl.util.randHSL({json: true, sat: 80}); // {hue: 169, sat: 80, lit: 60} Whirl.util.randHSL({json: true, lit: 45}); // {hue: 339, sat: 52, lit: 45} Random RGB \u00b6 Returns a random RGB (Red, Green, Blue) value of either a string or JSON object ( rgb(x, y, z) ). Whirl.util.randRGB(<cfg>) Object <cfg> Object that provides optional configuration variables when generating the RGB value. alpha - If given, the alpha value will also be given with the generated value ( rgb(x, y, z, a) ). json - If true , will return JSON representation of the RGB value instead of a string. Example(s): Whirl.util.randRGB(); // \"rgb(149, 64, 141)\" Whirl.util.randRGB(); // \"rgb(93, 223, 226)\" Whirl.util.randRGB({alpha: true}); // \"rgba(78, 159, 140, 0.3)\" Whirl.util.randRGB({json: true}); // {r: 207, g: 70, b: 192} Whirl.util.randRGB({alpha: true, json: true}); // {r: 66, g: 139, b: 72, a: 0.8} Shuffle Array \u00b6 Returns a shuffled copy of (not reference to) a given array. Does not mutate the original array, but returns a reference to a new shuffled array based on the original given array. Whirl.util.shuffleArr(<arr>) Array <arr> Array to be duplicated and shuffled. Example(s): Whirl.util.shuffleArr([1, 5, 3, 2]); // [2, 5, 3, 1] Whirl.util.shuffleArr([1, 5, 3, 2]); // [2, 1, 5, 3] Mathematical Functions \u00b6 Library of mathematical functions. Whirl.math.<function> Average \u00b6 Returns the average of the given set of numbers in an array. Whirl.math.average(<arr>) Array <arr> Array of numbers to averaged. Example(s): Whirl.math.average([1, 2, 3]); // 2 Whirl.math.average([1, 2, 3, 4]); // 2.5 Whirl.math.average([8, 3, 9.2, 12, 5.5]); // 7.540000000000001 Between Bounds \u00b6 Returns true if a given value is greater than or equal to a minimum value and less than a maximum value, otherwise returns false . Whirl.math.between(<val>, <min>, <max>, <leniency>) Number <val> Value to be checked if it is between the minimum and maximum. Number <min> Minimum value of the range to be checked. Number <max> Maximum value of the range to be checked. Number <leniency> (Optional) (Default: 0 ) If given, will still return true if the value is outside of the minimum or maximum range but still within the leniency value's range from the minimum or maximum value. For example, will still return true if <val> is two (2) , <min> is four (4) and <leniency> is three (3) because two (2) ( <val> ) is still at most three (3) ( <leniency> ) away from four (4) ( <min> ). Example(s): Whirl.math.between(8, 5, 10); // true Whirl.math.between(12, 5, 10); // false Whirl.math.between(12, 5, 10, 4); // true Clamp \u00b6 Clamps a given value between a given minimum and maximum value. Returns the given value if it is within the range, otherwise returns the minimum or maximum value if the value is lower than or greater than the given range, respectivly. Whirl.math.clamp(<val>, <min>, <max>) Number <val> Value to be clamped. Number <min> Minimum value of the range to be clamped to. Number <max> Minimum value of the range to be clamped to. Example(s): Whirl.math.clamp(10, 5, 15); // 10 Whirl.math.clamp(12, 5, 15); // 12 Whirl.math.clamp(3, 5, 15); // 5 Whirl.math.clamp(19, 5, 15); // 15 Linear Interpolation \u00b6 Interpolate between a given start and end value by a given interpolant value. Whirl.math.lerp(<start>, <end>, <through>) Number <start> Start or beginning value. Number <end> Last or ending value. Float <through> Value being the interpolant between the start and end values. Example(s): Whirl.math.lerp(0, 100, 0.1); // 10 Whirl.math.lerp(0, 50, 0.5); // 25 Whirl.math.lerp(50, 0, 0.5); // 25 Whirl.math.lerp(0, 50, 2); // 100 Map Value Between Ranges \u00b6 Extrapolate how far through a given range of values a given point is to another given range of values. For example, five (5) is fifty percent (50%) of the way between zero (0) and ten (10) . To map the given point linearly between the range zero (0) to ten (10) to the range fifty (50) to one-hundred (100) would mean going fifty percent (50%) of the way between fifty (50) and one-hundred (100) to get seventy-five (75) . Whirl.math.map(<value>, <in_min>, <in_max>, <out_min>, <out_max>) Number <value> Value to use as a point between the first given range. Number <in_min> Lower bound of the input range. Number <in_max> Upper bound of the input range. Number <out_min> Lower bound of the output range. Number <out_max> Upper bound of the output range. Example(s): Whirl.math.map(5, 3, 7, 50, 100); // 75 Whirl.math.map(25, 0, 50, 100, 200); // 150 Whirl.math.map(75, 50, 100, 1000, 2000); // 1500 Whirl.math.map(5, 10, 20, 100, 200); // 50 Random \u00b6 Returns a random float in the range of zero (0) to one (1) (inclusive of zero (0) but not of one (1)). If one argument is given then will return an integer in the range of zero (0) up to the given value. If two arguments are given then will return an integer in the range between the two given arguments. Whirl.math.random(<a>, <b>) Number <a> (Optional) If given without <b> being given, will be the upper bound of the range of the random number. If given with <b> being given, will be the lower bound of the range of the random number. Number <b> (Optional) The upper bound of the range of the random number. Example(s): Whirl.math.random(); // 0.6019569996537999 Whirl.math.random(); // 0.2947829307200911 Whirl.math.random(5); // 0 Whirl.math.random(5); // 4 Whirl.math.random(5, 10); // 7 Whirl.math.random(5, 10); // 9 Rounding \u00b6 Rounds a given value to the nearest multiple of a given value. If no rounding number is given, will round the value to the nearest integer. Whirl.math.roundTo(<num>, <rounder>) Number <num> Number to be rounded. Integer <rounder> (Optional) (Default: 1 ) Multiple to round the <num> value to. Example(s): Whirl.math.roundTo(89, 100); // 100 Whirl.math.roundTo(24, 100); // 0 Whirl.math.roundTo(5, 10); // 10 Whirl.math.roundTo(1729, 200); // 1800 Step Towards \u00b6 Steps/Increments a given value towards a target value by a given increment. If after stepping/incrementing the value it exceeds the target then the target itself will be returned. Whirl.math.stepTo(<val>, <target>, <increment>) Number <val> Value to step. Number <target> Target value to step the given value towards. Number <increment> (Optional) (Default: 1 ) Increment to move the given value by. Example(s): Whirl.math.stepTo(5, 10); // 6 Whirl.math.stepTo(5, 10, 3); // 8 Whirl.math.stepTo(6, 1, 3); // 3 Whirl.math.stepTo(7, 0, 8); // 0 Whirl.math.stepTo(10, 14, 20); // 14 Easing Functions \u00b6 Library of easing functions to alter the rate of change of a given value. Function Description Linear No acceleration. In Acceleration from zero velocity. Out Decelerating to zero velocity. In Out Acceleration until halfway, then deceleration. Linear \u00b6 Implies a linear rate of change ( t ). Whirl.easing.linear(<t>) Quadratic \u00b6 Implies a rate of change by a degree of two (2) ( t^2 ); Whirl.easing.quadratic.in(<t>) Whirl.easing.quadratic.out(<t>) Whirl.easing.quadratic.inOut(<t>) Cubic \u00b6 Implies a rate of change by a degree of three (3) ( t^3 ); Whirl.easing.cubic.in(<t>) Whirl.easing.cubic.out(<t>) Whirl.easing.cubic.inOut(<t>)","title":"In-Built Libraries"},{"location":"documentation/libraries/#in-built-libraries","text":"Below is documentation for libraries that Whirl provides that aren't necessarily needed when creating a game but can be convenient so as to not reinvent the wheel with common operations you may do as part of a game. Such libraries include general utility functions, mathematical functions and easing functions.","title":"In-Built Libraries"},{"location":"documentation/libraries/#utility-functions","text":"Library of general utility functions. Whirl.util.<function>","title":"Utility Functions"},{"location":"documentation/libraries/#format-comma","text":"Format a number to a string separating thousands with commas. Whirl.util.formatComma(<number>) Integer <number> Number to be formatted. Example(s): Whirl.util.formatComma(1); // \"1\" Whirl.util.formatComma(1000); // \"1,000\" Whirl.util.formatComma(3985721); // \"3,985,721\" Whirl.util.formatComma(9874.56); // \"9,874.56\"","title":"Format Comma"},{"location":"documentation/libraries/#random-value-from-array","text":"Returns a random value from a given array. Whirl.util.randArr(<arr>) Array <arr> Array to retrieve a random value from. Example(s): Whirl.util.randArr([1, 5, 2]); // 5 Whirl.util.randArr([1, 5, 2]); // 2 Whirl.util.randArr([3, 8, 9]); // 9","title":"Random Value from Array"},{"location":"documentation/libraries/#random-hsl","text":"Returns a random HSL (Hue, Saturation, Lightness) value of either a string or JSON object ( hsl(h, s, l) ). Whirl.util.randHSL(<cfg>) Object <cfg> Object that provides optional configuration variables when generating the HSL value. alpha - If given, the given alpha value will also be given with the generated value ( hsl(h, s, l, a) ). json - If true , will return a JSON representation of the HSL value instead of a string. sat - If given, will override the generated saturation value with the given value. lit - If given, will override the generated lightness value with the given value. Example(s): Whirl.util.randHSL(); // \"hsl(39, 3%, 7%)\" Whirl.util.randHSL(); // \"hsl(48, 85%, 78%)\" Whirl.util.randHSL({alpha: true}); // \"hsla(85, 15%, 67%, 0.8)\" Whirl.util.randHSL({json: true}); // {hue: 177, sat: 20, lit: 27} Whirl.util.randHSL({alpha: true, json: true}); // {hue: 174, sat: 66, lit: 40, a: 0.8} Whirl.util.randHSL({json: true, sat: 80}); // {hue: 169, sat: 80, lit: 60} Whirl.util.randHSL({json: true, lit: 45}); // {hue: 339, sat: 52, lit: 45}","title":"Random HSL"},{"location":"documentation/libraries/#random-rgb","text":"Returns a random RGB (Red, Green, Blue) value of either a string or JSON object ( rgb(x, y, z) ). Whirl.util.randRGB(<cfg>) Object <cfg> Object that provides optional configuration variables when generating the RGB value. alpha - If given, the alpha value will also be given with the generated value ( rgb(x, y, z, a) ). json - If true , will return JSON representation of the RGB value instead of a string. Example(s): Whirl.util.randRGB(); // \"rgb(149, 64, 141)\" Whirl.util.randRGB(); // \"rgb(93, 223, 226)\" Whirl.util.randRGB({alpha: true}); // \"rgba(78, 159, 140, 0.3)\" Whirl.util.randRGB({json: true}); // {r: 207, g: 70, b: 192} Whirl.util.randRGB({alpha: true, json: true}); // {r: 66, g: 139, b: 72, a: 0.8}","title":"Random RGB"},{"location":"documentation/libraries/#shuffle-array","text":"Returns a shuffled copy of (not reference to) a given array. Does not mutate the original array, but returns a reference to a new shuffled array based on the original given array. Whirl.util.shuffleArr(<arr>) Array <arr> Array to be duplicated and shuffled. Example(s): Whirl.util.shuffleArr([1, 5, 3, 2]); // [2, 5, 3, 1] Whirl.util.shuffleArr([1, 5, 3, 2]); // [2, 1, 5, 3]","title":"Shuffle Array"},{"location":"documentation/libraries/#mathematical-functions","text":"Library of mathematical functions. Whirl.math.<function>","title":"Mathematical Functions"},{"location":"documentation/libraries/#average","text":"Returns the average of the given set of numbers in an array. Whirl.math.average(<arr>) Array <arr> Array of numbers to averaged. Example(s): Whirl.math.average([1, 2, 3]); // 2 Whirl.math.average([1, 2, 3, 4]); // 2.5 Whirl.math.average([8, 3, 9.2, 12, 5.5]); // 7.540000000000001","title":"Average"},{"location":"documentation/libraries/#between-bounds","text":"Returns true if a given value is greater than or equal to a minimum value and less than a maximum value, otherwise returns false . Whirl.math.between(<val>, <min>, <max>, <leniency>) Number <val> Value to be checked if it is between the minimum and maximum. Number <min> Minimum value of the range to be checked. Number <max> Maximum value of the range to be checked. Number <leniency> (Optional) (Default: 0 ) If given, will still return true if the value is outside of the minimum or maximum range but still within the leniency value's range from the minimum or maximum value. For example, will still return true if <val> is two (2) , <min> is four (4) and <leniency> is three (3) because two (2) ( <val> ) is still at most three (3) ( <leniency> ) away from four (4) ( <min> ). Example(s): Whirl.math.between(8, 5, 10); // true Whirl.math.between(12, 5, 10); // false Whirl.math.between(12, 5, 10, 4); // true","title":"Between Bounds"},{"location":"documentation/libraries/#clamp","text":"Clamps a given value between a given minimum and maximum value. Returns the given value if it is within the range, otherwise returns the minimum or maximum value if the value is lower than or greater than the given range, respectivly. Whirl.math.clamp(<val>, <min>, <max>) Number <val> Value to be clamped. Number <min> Minimum value of the range to be clamped to. Number <max> Minimum value of the range to be clamped to. Example(s): Whirl.math.clamp(10, 5, 15); // 10 Whirl.math.clamp(12, 5, 15); // 12 Whirl.math.clamp(3, 5, 15); // 5 Whirl.math.clamp(19, 5, 15); // 15","title":"Clamp"},{"location":"documentation/libraries/#linear-interpolation","text":"Interpolate between a given start and end value by a given interpolant value. Whirl.math.lerp(<start>, <end>, <through>) Number <start> Start or beginning value. Number <end> Last or ending value. Float <through> Value being the interpolant between the start and end values. Example(s): Whirl.math.lerp(0, 100, 0.1); // 10 Whirl.math.lerp(0, 50, 0.5); // 25 Whirl.math.lerp(50, 0, 0.5); // 25 Whirl.math.lerp(0, 50, 2); // 100","title":"Linear Interpolation"},{"location":"documentation/libraries/#map-value-between-ranges","text":"Extrapolate how far through a given range of values a given point is to another given range of values. For example, five (5) is fifty percent (50%) of the way between zero (0) and ten (10) . To map the given point linearly between the range zero (0) to ten (10) to the range fifty (50) to one-hundred (100) would mean going fifty percent (50%) of the way between fifty (50) and one-hundred (100) to get seventy-five (75) . Whirl.math.map(<value>, <in_min>, <in_max>, <out_min>, <out_max>) Number <value> Value to use as a point between the first given range. Number <in_min> Lower bound of the input range. Number <in_max> Upper bound of the input range. Number <out_min> Lower bound of the output range. Number <out_max> Upper bound of the output range. Example(s): Whirl.math.map(5, 3, 7, 50, 100); // 75 Whirl.math.map(25, 0, 50, 100, 200); // 150 Whirl.math.map(75, 50, 100, 1000, 2000); // 1500 Whirl.math.map(5, 10, 20, 100, 200); // 50","title":"Map Value Between Ranges"},{"location":"documentation/libraries/#random","text":"Returns a random float in the range of zero (0) to one (1) (inclusive of zero (0) but not of one (1)). If one argument is given then will return an integer in the range of zero (0) up to the given value. If two arguments are given then will return an integer in the range between the two given arguments. Whirl.math.random(<a>, <b>) Number <a> (Optional) If given without <b> being given, will be the upper bound of the range of the random number. If given with <b> being given, will be the lower bound of the range of the random number. Number <b> (Optional) The upper bound of the range of the random number. Example(s): Whirl.math.random(); // 0.6019569996537999 Whirl.math.random(); // 0.2947829307200911 Whirl.math.random(5); // 0 Whirl.math.random(5); // 4 Whirl.math.random(5, 10); // 7 Whirl.math.random(5, 10); // 9","title":"Random"},{"location":"documentation/libraries/#rounding","text":"Rounds a given value to the nearest multiple of a given value. If no rounding number is given, will round the value to the nearest integer. Whirl.math.roundTo(<num>, <rounder>) Number <num> Number to be rounded. Integer <rounder> (Optional) (Default: 1 ) Multiple to round the <num> value to. Example(s): Whirl.math.roundTo(89, 100); // 100 Whirl.math.roundTo(24, 100); // 0 Whirl.math.roundTo(5, 10); // 10 Whirl.math.roundTo(1729, 200); // 1800","title":"Rounding"},{"location":"documentation/libraries/#step-towards","text":"Steps/Increments a given value towards a target value by a given increment. If after stepping/incrementing the value it exceeds the target then the target itself will be returned. Whirl.math.stepTo(<val>, <target>, <increment>) Number <val> Value to step. Number <target> Target value to step the given value towards. Number <increment> (Optional) (Default: 1 ) Increment to move the given value by. Example(s): Whirl.math.stepTo(5, 10); // 6 Whirl.math.stepTo(5, 10, 3); // 8 Whirl.math.stepTo(6, 1, 3); // 3 Whirl.math.stepTo(7, 0, 8); // 0 Whirl.math.stepTo(10, 14, 20); // 14","title":"Step Towards"},{"location":"documentation/libraries/#easing-functions","text":"Library of easing functions to alter the rate of change of a given value. Function Description Linear No acceleration. In Acceleration from zero velocity. Out Decelerating to zero velocity. In Out Acceleration until halfway, then deceleration.","title":"Easing Functions"},{"location":"documentation/libraries/#linear","text":"Implies a linear rate of change ( t ). Whirl.easing.linear(<t>)","title":"Linear"},{"location":"documentation/libraries/#quadratic","text":"Implies a rate of change by a degree of two (2) ( t^2 ); Whirl.easing.quadratic.in(<t>) Whirl.easing.quadratic.out(<t>) Whirl.easing.quadratic.inOut(<t>)","title":"Quadratic"},{"location":"documentation/libraries/#cubic","text":"Implies a rate of change by a degree of three (3) ( t^3 ); Whirl.easing.cubic.in(<t>) Whirl.easing.cubic.out(<t>) Whirl.easing.cubic.inOut(<t>)","title":"Cubic"},{"location":"documentation/systems/","text":"Object Systems \u00b6 Object systems are reusable pieces of code that can be attached to game objects during instantiation (Think React hooks, if you're familiar). Objects instantiated this way are stored in the global store unless specifically ordered not to be. You can read more about instantiating your own custom game elements in the customisation section , but for the most part in-built game objects (such as viewports, stages, sprites, plugins, etc.) will instantiate themselves in the game instance for you. To attach an object system to an object that is not already equipped with one you can call the attachSystem method. Objects must be instantiated in a game instance first to have a game system attached to them. [game].object.attachSystem(<obj>, <systems>) Object <obj> Object to attach the event system(s) to. Object <systems> Object indicating list of systems to attach to the given object. The property value must be set to true to register. The current valid object systems are: \u2022 event \u2022 tween \u2022 child Most in-built game objects will already come with object systems that are useful for their use case, so unless you are making your own custom game objects you may rarely need to attach extra object systems to objects you create. Example(s): Creating a custom sprite and then attaching the event and tween object system to it. // Create a new game instance and an empty object. const game = Whirl.Game(); const customSprite = {}; // Instantiate the empty object into the game instance. game.object.init(customSprite, \"Custom.Sprite\"); // Attach the `event` and `tween` system. game.object.attachSystem(customSprite, { event: true, tween: true }); Object systems can also be attached with the init method during instantiation as a third argument. game.object.init(customSprite, \"Custom.Sprite\", { event: true, tween: true }); The Global Store \u00b6 Most objects instantiated within a Whirl game instance are stored in what is called \"The Global Store\". This is a persistent list of all objects that exist in the current game instance. You can see the raw global store of your game instance under [game].globalStore but you should never modify this directly . You should also never rely on the order of the array representing the raw global store as it can change between game updates, object modification and other various ways. To traverse the global store you should use the provided methods under the object property of a game instance. [game].object Methods \u00b6 For all \"Get ...\" methods if no results are found (meaning no objects are matched) then an empty array will be returned ( [] ). Get All \u00b6 Returns an array of every item in the global store. [game].object.getAll() The returned array has no inherent ordering and thus the order the of the returned array will not necessarily be consistent on every call. Get By ID \u00b6 Returns an array of objects in the global store whose _id property match the given <id> search value. All objects that are instantiated within a game instance (Regardless of whether they are stored within the global store or not) are assigned a unique _id integer value that uniquely identifies every object created under the game instance since the game was instantiated. Keep in mind all IDs should be unique so although an array may be returned it should never have more than one value. [game].object.getById(<id>) Integer <id> Unique ID number by which to search the global store by. Get By Name \u00b6 Returns an array of objects in the global store whose name property matches the given <name> search string. Viewports, Stages, Sprites and Assets all a have name property that you provide when creating a new instance of them. [game].object.getByName(<name>) String <name> String to match an object's name by in the global store. Get By Type \u00b6 Returns an array of objects in the global store whose _type property matches the given <type> string. All objects instantiated under a game instance give a name for their \"type\" that identifies where the object came from and its own class. For example, a viewport's _type is Whirl.Viewport , and a sprite's _type is Whirl.Sprite . To learn more about types and making your own see the customisation section . [game].object.getByType(<type>) String <type> String to match an object's type by in the global store. Destroy By ID \u00b6 Removes an object from the global store given an <id> property and returns the removed object. Returns false if no object to remove is found. Use with caution: This method directly modifies the global store and therefore should not be used unless there are no other references to the object anywhere else in the game instance (such as being stored in a stage world, viewport, camera, etc.). Doing so may break functionality in unexpected and sometimes hard to debug ways. [game].object.destroyById(<id>) Integer <id> Unique ID number by which to search the global store by and match an object to be removed. Custom Events \u00b6 Whirl uses a dynamic event system to emit information from objects that can be picked up by listeners on that object. Many Whirl objects come with their own premade events, but you can also make your own that listen on or emit events from any object that has the event system attached to it. Events are identified by a given name. There can be multiple listeners on a single event that will all fire when that even is called. Listener callbacks are called in the order that the listeners were initially added in. Events do not have to be initialised beforehand. You can listen on any event name and it will be fired if something emits to that same name. [object].event Attach the event system to a game object: [game].object.attachSystem([object], {event: true}) Methods \u00b6 On \u00b6 Adds a new event listener for the given event name. [object].event.on(<name>, <callback>, <once>) String <name> Name of the event to listen on. Function <callback> Callback function that is called every time an event is emitted on the given event name. Takes a single object parameter that contains the emitted data. The object paramater also has attached to it the following properties: _eventId - The ID of the current event listener. _object - The object that the event is being called on. Boolean <once> (Optional) (Default: false ) If set to true will remove the event listener after one emit to the event name. Example(s): Listen for the event hit on the myPlayer object that when called upon will damage the player by the given damage value. myPlayer.event.on(\"hit\", (data) => { myPlayer.data.health -= data.damage; }); Listen for the event loadedImage that is listened to once and then when emitted to stops listening. myPlayer.event.on(\"loadedImage\", (data) => { console.log(\"Player image loaded!\"); }, true); On Once \u00b6 Implicitly the same as .event.on but with the <once> argument set to true . See the 'On' method parameters as they are the same except with the last parameter omitted. Example(s): myPlayer.event.onOnce(\"loadedImage\", (data) => { console.log(\"Player image loaded!\"); }); Emit \u00b6 Emits an event on the given name with given data. [object].event.emit(<name>, <data>) String <name> Name of the event to emit on. Object <data> (Optional) (Default: {} ) Data to emit with the event. You can add any property to this object, but do not overwrite the additional properties added by the event system ( _eventId and _object ). Example(s): Emit the hit event on the myPlayer object that passes damage: 5 on the data object. myPlayer.event.emit(\"hit\", { damage: 5 }); Remove By ID \u00b6 Removes a specific event listener by its unique identity number. Each event listener has a unique identification number that is passed to the callback function whenever the listener is emitted to in the _eventId property. [object].event.removeById(<name>, <id>) String <name> Name of the event. Integer <id> ID number of the listener within the event. Example(s): myPlayer.event.on(\"hit\", (data) => { myPlayer.data.health -= data.damage; // Make the player invincible so they can't be hit anymore by removing the event listener myPlayer.event.removeById(\"name\", data._eventId); }); Remove All \u00b6 Removes all event listeners on a specified event name. [object].event.removeAll(<name>) String <name> Name of the event to remove all listeners from. Example(s): Remove all listeners listening on the hit event on the myPlayer object. myPlayer.event.removeAll(\"hit\"); Animation Tweens \u00b6 Tweens are instructions that continually put intermediate frames between two points over a given time. Tweens are created, manipulated and deleted by the game instance's tween manager. You can create a tween using the tween manager directly or create a tween from object itself (on it's .tween property) which will implicitely call the tween manager. Creating a tween using the tween manager does not require the object to have the tween system attached to it as tween data is stored separately within the tween manager itself. To use the tween shorthand [object].tween you must first ensure that the tween system is attached to the object. Tweens are updated on the same tick as the main game loop, but the timing and duration is set independently of the game update rate. This means that the exact ending of a tween can occur at a different time to when the game finishes an update causing a slight millisecond delay between the tween finishing and the result being shown. [object].tween [game].tweenManager Attach the tween system to a game object: [game].object.attachSystem([object], {tween: true}) Tween \u00b6 Returns a Tween object that holds data about a tween and can be modified later. Create a tween on an object. Tweens cannot modify nested properties of an object. To modify a nested object then you must create a separate tween for that object itself. // Create a tween using the Tween Manager [game].tweenManager.create([object], [from], [to], [time], [presets]) // Create a tween using the Tween object system [object].tween([from], [to], [time], [presets]) Object <object> Object that the tween will apply to. Object <from> (Optional) (Default: {} ) Object that defines properties of the given <object> to edit and their values that are set from the beginning of the tween. Properties given here should correlate to the properties of the given <object> . Object <to> Object that defines properties of the given <object> to tween their values to (as opposed to from) the ending of the tween. Properties given here should correlate to the given properties of the given <object> . If no properties are given to the <from> object then instead of transitioning the values between the <from> and <to> objects the values will be transitioned from their pre-existing state and increased by the values given in the <to> object. For example, if an object's properties are {x: 20, y: 60} and the tween <from> object is {x: 50} and <to> is {x: 100} then the tween will transition the x property from 50 to 100 . If the <from> object is {} (or undefined ) and <to> is {x: 100} then the tween will transition the x property from 20 to 120 as the x property was 20 and is now being increased by 100 . Integer <time> Time (in milliseconds) that the tween takes to transition between the <from> and <to> values. Object <presets> Presets/Configuration to give to the tween. All presets are optional. Function easing - Easing function to use for the tween. See all Whirl easing functions . You may also supply a custom easing function. (Default: Whirl.easing.linear ). Boolean start - Begin the tween animation immediately as it is created (Default: true ). Number step - Value to step between on each update loop. After each update by the tween the value will be rounded to the given <step> value (Default: No rounding). Boolean roundValues - Whether the values being modified should be rounded to the nearest integer (Default: false ). Boolean loop - Whether the Tween will restart after completing. If a Tween has another Tween chained to it then it will not loop regardless of this flag (Default: false ). Boolean canPurge - Whether the Tween can be purged from the internal list of tweens stored in the tween manager (Default: true ). Child Hierarchy \u00b6 [object].child Attach the child system to a game object: [game].object.attachSystem([object], {child: true})","title":"Object Systems"},{"location":"documentation/systems/#object-systems","text":"Object systems are reusable pieces of code that can be attached to game objects during instantiation (Think React hooks, if you're familiar). Objects instantiated this way are stored in the global store unless specifically ordered not to be. You can read more about instantiating your own custom game elements in the customisation section , but for the most part in-built game objects (such as viewports, stages, sprites, plugins, etc.) will instantiate themselves in the game instance for you. To attach an object system to an object that is not already equipped with one you can call the attachSystem method. Objects must be instantiated in a game instance first to have a game system attached to them. [game].object.attachSystem(<obj>, <systems>) Object <obj> Object to attach the event system(s) to. Object <systems> Object indicating list of systems to attach to the given object. The property value must be set to true to register. The current valid object systems are: \u2022 event \u2022 tween \u2022 child Most in-built game objects will already come with object systems that are useful for their use case, so unless you are making your own custom game objects you may rarely need to attach extra object systems to objects you create. Example(s): Creating a custom sprite and then attaching the event and tween object system to it. // Create a new game instance and an empty object. const game = Whirl.Game(); const customSprite = {}; // Instantiate the empty object into the game instance. game.object.init(customSprite, \"Custom.Sprite\"); // Attach the `event` and `tween` system. game.object.attachSystem(customSprite, { event: true, tween: true }); Object systems can also be attached with the init method during instantiation as a third argument. game.object.init(customSprite, \"Custom.Sprite\", { event: true, tween: true });","title":"Object Systems"},{"location":"documentation/systems/#the-global-store","text":"Most objects instantiated within a Whirl game instance are stored in what is called \"The Global Store\". This is a persistent list of all objects that exist in the current game instance. You can see the raw global store of your game instance under [game].globalStore but you should never modify this directly . You should also never rely on the order of the array representing the raw global store as it can change between game updates, object modification and other various ways. To traverse the global store you should use the provided methods under the object property of a game instance. [game].object","title":"The Global Store"},{"location":"documentation/systems/#methods","text":"For all \"Get ...\" methods if no results are found (meaning no objects are matched) then an empty array will be returned ( [] ).","title":"Methods"},{"location":"documentation/systems/#get-all","text":"Returns an array of every item in the global store. [game].object.getAll() The returned array has no inherent ordering and thus the order the of the returned array will not necessarily be consistent on every call.","title":"Get All"},{"location":"documentation/systems/#get-by-id","text":"Returns an array of objects in the global store whose _id property match the given <id> search value. All objects that are instantiated within a game instance (Regardless of whether they are stored within the global store or not) are assigned a unique _id integer value that uniquely identifies every object created under the game instance since the game was instantiated. Keep in mind all IDs should be unique so although an array may be returned it should never have more than one value. [game].object.getById(<id>) Integer <id> Unique ID number by which to search the global store by.","title":"Get By ID"},{"location":"documentation/systems/#get-by-name","text":"Returns an array of objects in the global store whose name property matches the given <name> search string. Viewports, Stages, Sprites and Assets all a have name property that you provide when creating a new instance of them. [game].object.getByName(<name>) String <name> String to match an object's name by in the global store.","title":"Get By Name"},{"location":"documentation/systems/#get-by-type","text":"Returns an array of objects in the global store whose _type property matches the given <type> string. All objects instantiated under a game instance give a name for their \"type\" that identifies where the object came from and its own class. For example, a viewport's _type is Whirl.Viewport , and a sprite's _type is Whirl.Sprite . To learn more about types and making your own see the customisation section . [game].object.getByType(<type>) String <type> String to match an object's type by in the global store.","title":"Get By Type"},{"location":"documentation/systems/#destroy-by-id","text":"Removes an object from the global store given an <id> property and returns the removed object. Returns false if no object to remove is found. Use with caution: This method directly modifies the global store and therefore should not be used unless there are no other references to the object anywhere else in the game instance (such as being stored in a stage world, viewport, camera, etc.). Doing so may break functionality in unexpected and sometimes hard to debug ways. [game].object.destroyById(<id>) Integer <id> Unique ID number by which to search the global store by and match an object to be removed.","title":"Destroy By ID"},{"location":"documentation/systems/#custom-events","text":"Whirl uses a dynamic event system to emit information from objects that can be picked up by listeners on that object. Many Whirl objects come with their own premade events, but you can also make your own that listen on or emit events from any object that has the event system attached to it. Events are identified by a given name. There can be multiple listeners on a single event that will all fire when that even is called. Listener callbacks are called in the order that the listeners were initially added in. Events do not have to be initialised beforehand. You can listen on any event name and it will be fired if something emits to that same name. [object].event Attach the event system to a game object: [game].object.attachSystem([object], {event: true})","title":"Custom Events"},{"location":"documentation/systems/#methods_1","text":"","title":"Methods"},{"location":"documentation/systems/#on","text":"Adds a new event listener for the given event name. [object].event.on(<name>, <callback>, <once>) String <name> Name of the event to listen on. Function <callback> Callback function that is called every time an event is emitted on the given event name. Takes a single object parameter that contains the emitted data. The object paramater also has attached to it the following properties: _eventId - The ID of the current event listener. _object - The object that the event is being called on. Boolean <once> (Optional) (Default: false ) If set to true will remove the event listener after one emit to the event name. Example(s): Listen for the event hit on the myPlayer object that when called upon will damage the player by the given damage value. myPlayer.event.on(\"hit\", (data) => { myPlayer.data.health -= data.damage; }); Listen for the event loadedImage that is listened to once and then when emitted to stops listening. myPlayer.event.on(\"loadedImage\", (data) => { console.log(\"Player image loaded!\"); }, true);","title":"On"},{"location":"documentation/systems/#on-once","text":"Implicitly the same as .event.on but with the <once> argument set to true . See the 'On' method parameters as they are the same except with the last parameter omitted. Example(s): myPlayer.event.onOnce(\"loadedImage\", (data) => { console.log(\"Player image loaded!\"); });","title":"On Once"},{"location":"documentation/systems/#emit","text":"Emits an event on the given name with given data. [object].event.emit(<name>, <data>) String <name> Name of the event to emit on. Object <data> (Optional) (Default: {} ) Data to emit with the event. You can add any property to this object, but do not overwrite the additional properties added by the event system ( _eventId and _object ). Example(s): Emit the hit event on the myPlayer object that passes damage: 5 on the data object. myPlayer.event.emit(\"hit\", { damage: 5 });","title":"Emit"},{"location":"documentation/systems/#remove-by-id","text":"Removes a specific event listener by its unique identity number. Each event listener has a unique identification number that is passed to the callback function whenever the listener is emitted to in the _eventId property. [object].event.removeById(<name>, <id>) String <name> Name of the event. Integer <id> ID number of the listener within the event. Example(s): myPlayer.event.on(\"hit\", (data) => { myPlayer.data.health -= data.damage; // Make the player invincible so they can't be hit anymore by removing the event listener myPlayer.event.removeById(\"name\", data._eventId); });","title":"Remove By ID"},{"location":"documentation/systems/#remove-all","text":"Removes all event listeners on a specified event name. [object].event.removeAll(<name>) String <name> Name of the event to remove all listeners from. Example(s): Remove all listeners listening on the hit event on the myPlayer object. myPlayer.event.removeAll(\"hit\");","title":"Remove All"},{"location":"documentation/systems/#animation-tweens","text":"Tweens are instructions that continually put intermediate frames between two points over a given time. Tweens are created, manipulated and deleted by the game instance's tween manager. You can create a tween using the tween manager directly or create a tween from object itself (on it's .tween property) which will implicitely call the tween manager. Creating a tween using the tween manager does not require the object to have the tween system attached to it as tween data is stored separately within the tween manager itself. To use the tween shorthand [object].tween you must first ensure that the tween system is attached to the object. Tweens are updated on the same tick as the main game loop, but the timing and duration is set independently of the game update rate. This means that the exact ending of a tween can occur at a different time to when the game finishes an update causing a slight millisecond delay between the tween finishing and the result being shown. [object].tween [game].tweenManager Attach the tween system to a game object: [game].object.attachSystem([object], {tween: true})","title":"Animation Tweens"},{"location":"documentation/systems/#tween","text":"Returns a Tween object that holds data about a tween and can be modified later. Create a tween on an object. Tweens cannot modify nested properties of an object. To modify a nested object then you must create a separate tween for that object itself. // Create a tween using the Tween Manager [game].tweenManager.create([object], [from], [to], [time], [presets]) // Create a tween using the Tween object system [object].tween([from], [to], [time], [presets]) Object <object> Object that the tween will apply to. Object <from> (Optional) (Default: {} ) Object that defines properties of the given <object> to edit and their values that are set from the beginning of the tween. Properties given here should correlate to the properties of the given <object> . Object <to> Object that defines properties of the given <object> to tween their values to (as opposed to from) the ending of the tween. Properties given here should correlate to the given properties of the given <object> . If no properties are given to the <from> object then instead of transitioning the values between the <from> and <to> objects the values will be transitioned from their pre-existing state and increased by the values given in the <to> object. For example, if an object's properties are {x: 20, y: 60} and the tween <from> object is {x: 50} and <to> is {x: 100} then the tween will transition the x property from 50 to 100 . If the <from> object is {} (or undefined ) and <to> is {x: 100} then the tween will transition the x property from 20 to 120 as the x property was 20 and is now being increased by 100 . Integer <time> Time (in milliseconds) that the tween takes to transition between the <from> and <to> values. Object <presets> Presets/Configuration to give to the tween. All presets are optional. Function easing - Easing function to use for the tween. See all Whirl easing functions . You may also supply a custom easing function. (Default: Whirl.easing.linear ). Boolean start - Begin the tween animation immediately as it is created (Default: true ). Number step - Value to step between on each update loop. After each update by the tween the value will be rounded to the given <step> value (Default: No rounding). Boolean roundValues - Whether the values being modified should be rounded to the nearest integer (Default: false ). Boolean loop - Whether the Tween will restart after completing. If a Tween has another Tween chained to it then it will not loop regardless of this flag (Default: false ). Boolean canPurge - Whether the Tween can be purged from the internal list of tweens stored in the tween manager (Default: true ).","title":"Tween"},{"location":"documentation/systems/#child-hierarchy","text":"[object].child Attach the child system to a game object: [game].object.attachSystem([object], {child: true})","title":"Child Hierarchy"},{"location":"getting-started/","text":"Getting Started \u00b6 This article will be an introduction to the Whirl game engine showcasing certain features and building a small interactive application. After completing this walkthrough you are encouraged to read the full documentation to get an in-depth understanding of what each feature of the engine does, what it is and how to use it. Installation and Setup \u00b6 The first thing we need is the engine itself. Follow the four simple steps in the installation guide to build the JavaScript file from the source code, then open examples/Simple Setup/index.html file in your browser and the script.js in a text editor of your choice. If you have done everything correctly you should see an empty black screen with a white box - that is the canvas we will be drawing to. The Starter File \u00b6 We will mainly be working in the script.js file located in the /Simple Setup/ example project directory. Let's take a look a look at what is set up for us beforehand. Here is the code we are given: function update(data) { } function setup(data) { const {game, viewport, stage, camera} = data; } Whirl.Game() .setup({ setup, update canvas: \"#canvas\", cW: 400, cH: 400 }) .start(); Let's go through each line one by one. function update(data) { This is our own function that we give to Whirl - it will be called once every update loop. You can use this function to update, modify and check objects within your game world or have anything you could want to run once every frame here. function setup(data) { const {game, viewport, stage, camera} = data; } This is our own function that we give to Whirl - it will be called after the engine has finished setting up things like game state, the game canvas, viewports, game worlds, etc. You can use this function to perform all the setup your game will need such as creating objects, inserting sprites, positioning cameras, loading assets and more. We will get into doing some of these later on. Our function receives a single paramater data that gives us access to new objects created by the game setup. We will go into what a \"viewport\", \"stage\" and \"camera\" is later. For now know that game is a reference to the game instance are creating. Whirl.Game() To create a game we must create a new instance of the game class that Whirl provides us. When Whirl.Game() is called it will internally set up everything the game needs to run such as mouse and keyboard input, custom plugins and other various useful functions and processes. You can also configure certain aspects of the game instance by passing configuration variables as a JavaScript object to this function, but we'll just keep everything default for now. .setup({ setup, update canvas: \"#canvas\", cW: 400, cH: 400 }) We could set up everything we want for the game ourself; the canvas, viewport, game world, event hooks, etc. but this requires a bit of code and we want to get started as quickly as possible. Thankfully for us Whirl provides a handy setup function that will automatically do this all for us. We pass our setup and update functions (using the new ES6 object property shorthand) as the properties setup and update respectively to indicate that when the game starts we want our setup function to be called and each time the game updates we want our update function to be called. canvas: \"#canvas\" tells Whirl to render to the canvas with the given ID canvas (Check the index.html file in the /Simple Setup/ directory!). cW: 400 and cH: 400 will set our canvas size to be 400x400 pixels. .start(); After that code we call our start() method to begin running the game. Let's recap what the code given to us has done: Created a new Whirl game instance. Told the game to call our setup function when the game is finished setting up and our update function after each update loop. Provide a canvas element for the game to render to. Start the game loop. Our game is now being rendered to the canvas, but it remains empty because there is nothing to render yet. Creating our First Sprite \u00b6 Advanced: Setting Up From Scratch \u00b6 This article will detail how to set up a game yourself from scratch without the use of the .setup method to do it for you. It will go into how to create your own viewport, your own stage and a custom camera, as well as utilising event listeners to define your own functions that are called exactly when you want them to be (such as the update and setup functions given to the .setup method). Touched on briefly will also be information about the innerworkings of the game setup and a game instance's updater.","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"This article will be an introduction to the Whirl game engine showcasing certain features and building a small interactive application. After completing this walkthrough you are encouraged to read the full documentation to get an in-depth understanding of what each feature of the engine does, what it is and how to use it.","title":"Getting Started"},{"location":"getting-started/#installation-and-setup","text":"The first thing we need is the engine itself. Follow the four simple steps in the installation guide to build the JavaScript file from the source code, then open examples/Simple Setup/index.html file in your browser and the script.js in a text editor of your choice. If you have done everything correctly you should see an empty black screen with a white box - that is the canvas we will be drawing to.","title":"Installation and Setup"},{"location":"getting-started/#the-starter-file","text":"We will mainly be working in the script.js file located in the /Simple Setup/ example project directory. Let's take a look a look at what is set up for us beforehand. Here is the code we are given: function update(data) { } function setup(data) { const {game, viewport, stage, camera} = data; } Whirl.Game() .setup({ setup, update canvas: \"#canvas\", cW: 400, cH: 400 }) .start(); Let's go through each line one by one. function update(data) { This is our own function that we give to Whirl - it will be called once every update loop. You can use this function to update, modify and check objects within your game world or have anything you could want to run once every frame here. function setup(data) { const {game, viewport, stage, camera} = data; } This is our own function that we give to Whirl - it will be called after the engine has finished setting up things like game state, the game canvas, viewports, game worlds, etc. You can use this function to perform all the setup your game will need such as creating objects, inserting sprites, positioning cameras, loading assets and more. We will get into doing some of these later on. Our function receives a single paramater data that gives us access to new objects created by the game setup. We will go into what a \"viewport\", \"stage\" and \"camera\" is later. For now know that game is a reference to the game instance are creating. Whirl.Game() To create a game we must create a new instance of the game class that Whirl provides us. When Whirl.Game() is called it will internally set up everything the game needs to run such as mouse and keyboard input, custom plugins and other various useful functions and processes. You can also configure certain aspects of the game instance by passing configuration variables as a JavaScript object to this function, but we'll just keep everything default for now. .setup({ setup, update canvas: \"#canvas\", cW: 400, cH: 400 }) We could set up everything we want for the game ourself; the canvas, viewport, game world, event hooks, etc. but this requires a bit of code and we want to get started as quickly as possible. Thankfully for us Whirl provides a handy setup function that will automatically do this all for us. We pass our setup and update functions (using the new ES6 object property shorthand) as the properties setup and update respectively to indicate that when the game starts we want our setup function to be called and each time the game updates we want our update function to be called. canvas: \"#canvas\" tells Whirl to render to the canvas with the given ID canvas (Check the index.html file in the /Simple Setup/ directory!). cW: 400 and cH: 400 will set our canvas size to be 400x400 pixels. .start(); After that code we call our start() method to begin running the game. Let's recap what the code given to us has done: Created a new Whirl game instance. Told the game to call our setup function when the game is finished setting up and our update function after each update loop. Provide a canvas element for the game to render to. Start the game loop. Our game is now being rendered to the canvas, but it remains empty because there is nothing to render yet.","title":"The Starter File"},{"location":"getting-started/#creating-our-first-sprite","text":"","title":"Creating our First Sprite"},{"location":"getting-started/#advanced-setting-up-from-scratch","text":"This article will detail how to set up a game yourself from scratch without the use of the .setup method to do it for you. It will go into how to create your own viewport, your own stage and a custom camera, as well as utilising event listeners to define your own functions that are called exactly when you want them to be (such as the update and setup functions given to the .setup method). Touched on briefly will also be information about the innerworkings of the game setup and a game instance's updater.","title":"Advanced: Setting Up From Scratch"}]}